<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <title>ChatHaven - Servers & Channels</title>
 <link rel="stylesheet" href="./server.css">
 <style>
 /* Delete button styles */
 .message {
 position: relative;
 }
 
 .delete-btn {
 position: absolute;
 top: 3px;
 right: 3px;
 background-color: rgba(255, 0, 0, 0.1);
 color: #ff0000;
 border: none;
 width: 20px;
 height: 20px;
 border-radius: 50%;
 font-size: 14px;
 cursor: pointer;
 display: none;
 align-items: center;
 justify-content: center;
 padding: 0;
 line-height: 1;
 }
 
 .message:hover .delete-btn {
 display: flex;
 }
 
 .delete-btn:hover {
 background-color: rgba(255, 0, 0, 0.2);
 }

 /* Ensure settings button is always visible */
 #settingsButton {
   display: block !important; /* Use !important to override any inline styles */
   padding: 8px 12px;
   background-color: #333;
   color: white;
   border: none;
   cursor: pointer;
   font-size: 14px;
   border-radius: 5px;
 }

 /* Make the settings dropdown properly positioned for all users */
 .settings-container {
   position: relative;
   display: inline-block;
 }

 .dropdown-menu {
   right: 0;
   top: 40px;
   z-index: 10;
 }
 
 /* Members sidebar styles */
 .members-sidebar {
   width: 200px;
   background: #2C2F33;
   color: white;
   padding: 20px;
   display: flex;
   flex-direction: column;
   border-left: 1px solid #555;
 }
 
 .members-section {
   margin-top: 10px;
   max-height: 100%;
   overflow-y: auto;
 }
 
 .member-item {
   padding: 8px;
   margin: 5px 0;
   background: #444;
   border-radius: 5px;
   display: flex;
   align-items: center;
   justify-content: space-between;
 }
 
 .member-name {
   color: white;
   font-size: 14px;
 }
 
 .member-role {
   font-size: 10px;
   padding: 2px 5px;
   border-radius: 3px;
   color: white;
 }
 
 .role-owner {
   background-color: #ff9800;
 }
 
 .role-admin {
   background-color: #4CAF50;
 }
 
 .role-member {
   background-color: #2196F3;
 }

 /* Updated chat container to include members sidebar */
 .chat-container {
   display: flex;
   width: 90%;
   height: 600px;
   background: white;
   border-radius: 10px;
   overflow: hidden;
   box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.2);
 }
 
 /* Updated chat box width */
 .chat-box {
   flex: 1;
   display: flex;
   flex-direction: column;
 }

 /* Channel type styles */
 .channel {
   position: relative;
 }
 
 .channel-info {
   display: flex;
   justify-content: space-between;
   align-items: center;
   width: 100%;
 }
 
 .channel-type-badge {
   font-size: 10px;
   padding: 2px 6px;
   border-radius: 10px;
   margin-left: 5px;
 }
 
 .badge-public {
   background-color: #4CAF50;
   color: white;
 }
 
 .badge-private {
   background-color: #f44336;
   color: white;
 }
 
 .request-access-btn {
   display: block;
   width: 100%;
   margin-top: 5px;
   padding: 5px;
   background-color: #2196F3;
   color: white;
   border: none;
   border-radius: 3px;
   cursor: pointer;
   font-size: 12px;
   text-align: center;
 }
 
 .access-request-notification {
   position: fixed;
   bottom: 20px;
   right: 20px;
   background-color: #333;
   color: white;
   padding: 15px;
   border-radius: 5px;
   box-shadow: 0 4px 8px rgba(0,0,0,0.2);
   z-index: 1000;
   display: flex;
   flex-direction: column;
   max-width: 300px;
 }
 
 .notification-buttons {
   display: flex;
   justify-content: flex-end;
   margin-top: 10px;
   gap: 10px;
 }
 
 .access-approve-btn {
   background-color: #4CAF50;
   color: white;
   border: none;
   padding: 5px 10px;
   border-radius: 3px;
   cursor: pointer;
 }
 
 .access-deny-btn {
   background-color: #f44336;
   color: white;
   border: none;
   padding: 5px 10px;
   border-radius: 3px;
   cursor: pointer;
 }

 /* Channel access management styles */
 .channel-access-item {
   display: flex;
   justify-content: space-between;
   align-items: center;
   padding: 10px;
   margin: 10px 0;
   background: #f8f9fa;
   border-radius: 8px;
   box-shadow: 0 2px 4px rgba(0,0,0,0.1);
 }
 
 .channel-access-button {
   padding: 8px 16px;
   border: none;
   border-radius: 20px;
   cursor: pointer;
   font-weight: 500;
   transition: all 0.2s ease;
 }
 
 .allow-access {
   background: #4CAF50;
   color: white;
 }
 
 .allow-access:hover {
   background: #45a049;
 }
 
 .remove-access {
   background: #f44336;
   color: white;
 }
 
 .remove-access:hover {
   background: #d32f2f;
 }
 </style>
</head>
<body>
 <div class="chat-container">
 <!-- Left Sidebar -->
 <div class="sidebar">
 <!-- Server Section -->
 <div class="server-section" id="serverSectionView">
 <h2>Servers</h2>
 <input type="text" id="searchServer" placeholder="Search for a server...">
 <button id="createServer">+ Create Server</button>
 <div id="serverList"></div>
 </div>

 <!-- Channel Section (hidden initially) -->
 <div class="channel-section" id="channelSectionView">
 <button class="back-button" id="backToServers">â† Back to Servers</button>
 <h2 id="currentServerName">Server Name</h2>
 <div class="divider"></div>
 <h3>CHANNELS</h3>
 <input type="text" id="searchChannel" placeholder="Search for a channel...">
 <button id="createChannel">+ Create Channel</button>
 <div id="channelList"></div>
 </div>
 </div>

 <!-- Chat Box -->
 <div class="chat-box">
 <div class="chat-header">
 <h2 id="chatChannelName">Select a server and channel to chat</h2>
 <!-- Settings Button -->
 <div class="settings-container">
 <button id="settingsButton">âš™ Settings</button>
 <div class="dropdown-menu" id="settingsDropdown">
 <button id="addMember">â• Add Member</button>
 <button id="manageMembers">ğŸ‘¥ Manage Members</button>
 <button id="deleteChannel">ğŸ—‘ï¸ Delete Channel</button>
 <button id="manageChannelAccess">ğŸ”’ Manage Channel Access</button>
 <button id="deleteServer">âŒ Delete Server</button>
 <button id="leaveServer">ğŸšª Leave Server</button>
 </div>
 </div>
 </div>

 <div id="messages"></div>
 <div class="message-input">
 <div class="emoji-container">
  <button id="emojiButton">ğŸ˜Š</button>
  <div id="emojiPicker" style="display: none;">
  <div class="emoji-tabs">
  <button class="emoji-tab active" data-category="smileys">ğŸ˜€</button>
  <button class="emoji-tab" data-category="animals">ğŸ±</button>
  <button class="emoji-tab" data-category="food">ğŸ”</button>
  <button class="emoji-tab" data-category="symbols">â¤ï¸</button>
  </div>
  <div class="emoji-content">
  <div class="emoji-category active" id="smileys">
  <span class="emoji" data-emoji="ğŸ˜€">ğŸ˜€</span>
  <span class="emoji" data-emoji="ğŸ˜ƒ">ğŸ˜ƒ</span>
  <span class="emoji" data-emoji="ğŸ˜„">ğŸ˜„</span>
  <span class="emoji" data-emoji="ğŸ˜">ğŸ˜</span>
  <span class="emoji" data-emoji="ğŸ˜†">ğŸ˜†</span>
  <span class="emoji" data-emoji="ğŸ˜…">ğŸ˜…</span>
  <span class="emoji" data-emoji="ğŸ¤£">ğŸ¤£</span>
  <span class="emoji" data-emoji="ğŸ˜‚">ğŸ˜‚</span>
  <span class="emoji" data-emoji="ğŸ™‚">ğŸ™‚</span>
  <span class="emoji" data-emoji="ğŸ™ƒ">ğŸ™ƒ</span>
  <span class="emoji" data-emoji="ğŸ˜‰">ğŸ˜‰</span>
  <span class="emoji" data-emoji="ğŸ˜Š">ğŸ˜Š</span>
  <span class="emoji" data-emoji="ğŸ˜‡">ğŸ˜‡</span>
  <span class="emoji" data-emoji="ğŸ¥°">ğŸ¥°</span>
  <span class="emoji" data-emoji="ğŸ˜">ğŸ˜</span>
  <span class="emoji" data-emoji="ğŸ¤©">ğŸ¤©</span>
  <span class="emoji" data-emoji="ğŸ˜˜">ğŸ˜˜</span>
  <span class="emoji" data-emoji="ğŸ˜—">ğŸ˜—</span>
  <span class="emoji" data-emoji="ğŸ˜š">ğŸ˜š</span>
  <span class="emoji" data-emoji="ğŸ˜™">ğŸ˜™</span>
  <span class="emoji" data-emoji="ğŸ¥²">ğŸ¥²</span>
  <span class="emoji" data-emoji="ğŸ˜‹">ğŸ˜‹</span>
  <span class="emoji" data-emoji="ğŸ˜›">ğŸ˜›</span>
  <span class="emoji" data-emoji="ğŸ˜œ">ğŸ˜œ</span>
  <span class="emoji" data-emoji="ğŸ¤ª">ğŸ¤ª</span>
  <span class="emoji" data-emoji="ğŸ˜">ğŸ˜</span>
  <span class="emoji" data-emoji="ğŸ¤‘">ğŸ¤‘</span>
  <span class="emoji" data-emoji="ğŸ¤—">ğŸ¤—</span>
  <span class="emoji" data-emoji="ğŸ¤­">ğŸ¤­</span>
  <span class="emoji" data-emoji="ğŸ¤«">ğŸ¤«</span>
  <span class="emoji" data-emoji="ğŸ¤”">ğŸ¤”</span>
  <span class="emoji" data-emoji="ğŸ¤¤">ğŸ¤¤</span>
  <span class="emoji" data-emoji="ğŸ¤">ğŸ¤</span>
  <span class="emoji" data-emoji="ğŸ¥´">ğŸ¥´</span>
  <span class="emoji" data-emoji="ğŸ˜´">ğŸ˜´</span>
  <span class="emoji" data-emoji="ğŸ¥±">ğŸ¥±</span>
  <span class="emoji" data-emoji="ğŸ˜·">ğŸ˜·</span>
  <span class="emoji" data-emoji="ğŸ–•">ğŸ–•</span>
  <span class="emoji" data-emoji="ğŸ’€">ğŸ’€</span>
  <span class="emoji" data-emoji="ğŸ’©">ğŸ’©</span>
  <span class="emoji" data-emoji="ğŸ¤¢">ğŸ¤¢</span>
 </div>
  <div class="emoji-category" id="animals">
  <span class="emoji" data-emoji="ğŸ¶">ğŸ¶</span>
  <span class="emoji" data-emoji="ğŸ±">ğŸ±</span>
  <span class="emoji" data-emoji="ğŸ­">ğŸ­</span>
  <span class="emoji" data-emoji="ğŸ¹">ğŸ¹</span>
  <span class="emoji" data-emoji="ğŸ°">ğŸ°</span>
  <span class="emoji" data-emoji="ğŸ¦Š">ğŸ¦Š</span>
  <span class="emoji" data-emoji="ğŸ»">ğŸ»</span>
  <span class="emoji" data-emoji="ğŸ¼">ğŸ¼</span>
  <span class="emoji" data-emoji="ğŸ¨">ğŸ¨</span>
  <span class="emoji" data-emoji="ğŸ¯">ğŸ¯</span>
  <span class="emoji" data-emoji="ğŸ¦">ğŸ¦</span>
  <span class="emoji" data-emoji="ğŸ®">ğŸ®</span>
  <span class="emoji" data-emoji="ğŸ·">ğŸ·</span>
  <span class="emoji" data-emoji="ğŸ¸">ğŸ¸</span>
  <span class="emoji" data-emoji="ğŸµ">ğŸµ</span>
  <span class="emoji" data-emoji="ğŸ”">ğŸ”</span>
  <span class="emoji" data-emoji="ğŸ§">ğŸ§</span>
  <span class="emoji" data-emoji="ğŸ¦">ğŸ¦</span>
  <span class="emoji" data-emoji="ğŸ¦„">ğŸ¦„</span>
  <span class="emoji" data-emoji="ğŸ¦‡">ğŸ¦‡</span>
  <span class="emoji" data-emoji="ğŸ¦‰">ğŸ¦‰</span>
  <span class="emoji" data-emoji="ğŸ¦‹">ğŸ¦‹</span>
  <span class="emoji" data-emoji="ğŸ">ğŸ</span>
  <span class="emoji" data-emoji="ğŸ¢">ğŸ¢</span>
  <span class="emoji" data-emoji="ğŸ™">ğŸ™</span>
  <span class="emoji" data-emoji="ğŸ¦‘">ğŸ¦‘</span>
  <span class="emoji" data-emoji="ğŸ¦">ğŸ¦</span>
  <span class="emoji" data-emoji="ğŸ¦€">ğŸ¦€</span>
  <span class="emoji" data-emoji="ğŸ¬">ğŸ¬</span>
  <span class="emoji" data-emoji="ğŸ³">ğŸ³</span>
  </div>
  <div class="emoji-category" id="food">
  <span class="emoji" data-emoji="ğŸ">ğŸ</span>
  <span class="emoji" data-emoji="ğŸ">ğŸ</span>
  <span class="emoji" data-emoji="ğŸŠ">ğŸŠ</span>
  <span class="emoji" data-emoji="ğŸ‹">ğŸ‹</span>
  <span class="emoji" data-emoji="ğŸŒ">ğŸŒ</span>
  <span class="emoji" data-emoji="ğŸ‰">ğŸ‰</span>
  <span class="emoji" data-emoji="ğŸ‡">ğŸ‡</span>
  <span class="emoji" data-emoji="ğŸ“">ğŸ“</span>
  <span class="emoji" data-emoji="ğŸˆ">ğŸˆ</span>
  <span class="emoji" data-emoji="ğŸ’">ğŸ’</span>
  <span class="emoji" data-emoji="ğŸ‘">ğŸ‘</span>
  <span class="emoji" data-emoji="ğŸ¥­">ğŸ¥­</span>
  <span class="emoji" data-emoji="ğŸ">ğŸ</span>
  <span class="emoji" data-emoji="ğŸ¥¥">ğŸ¥¥</span>
  <span class="emoji" data-emoji="ğŸ¥">ğŸ¥</span>
  <span class="emoji" data-emoji="ğŸ…">ğŸ…</span>
  <span class="emoji" data-emoji="ğŸ†">ğŸ†</span>
  <span class="emoji" data-emoji="ğŸ¥‘">ğŸ¥‘</span>
  <span class="emoji" data-emoji="ğŸ¥¦">ğŸ¥¦</span>
  <span class="emoji" data-emoji="ğŸ¥¬">ğŸ¥¬</span>
  <span class="emoji" data-emoji="ğŸ¥•">ğŸ¥•</span>
  <span class="emoji" data-emoji="ğŸŒ½">ğŸŒ½</span>
  <span class="emoji" data-emoji="ğŸŒ¶ï¸">ğŸŒ¶ï¸</span>
  <span class="emoji" data-emoji="ğŸ¥">ğŸ¥</span>
  <span class="emoji" data-emoji="ğŸ">ğŸ</span>
  <span class="emoji" data-emoji="ğŸ¥¨">ğŸ¥¨</span>
  <span class="emoji" data-emoji="ğŸ”">ğŸ”</span>
  <span class="emoji" data-emoji="ğŸŸ">ğŸŸ</span>
  <span class="emoji" data-emoji="ğŸ•">ğŸ•</span>
  <span class="emoji" data-emoji="ğŸŒ­">ğŸŒ­</span>
  <span class="emoji" data-emoji="ğŸ¿">ğŸ¿</span>
  <span class="emoji" data-emoji="ğŸ§">ğŸ§</span>
  <span class="emoji" data-emoji="ğŸ°">ğŸ°</span>
  <span class="emoji" data-emoji="ğŸ«">ğŸ«</span>
  <span class="emoji" data-emoji="ğŸ¬">ğŸ¬</span>
  </div>
  <div class="emoji-category" id="symbols">
  <span class="emoji" data-emoji="â¤ï¸">â¤ï¸</span>
  <span class="emoji" data-emoji="ğŸ§¡">ğŸ§¡</span>
  <span class="emoji" data-emoji="ğŸ’›">ğŸ’›</span>
  <span class="emoji" data-emoji="ğŸ’š">ğŸ’š</span>
  <span class="emoji" data-emoji="ğŸ’™">ğŸ’™</span>
  <span class="emoji" data-emoji="ğŸ’œ">ğŸ’œ</span>
  <span class="emoji" data-emoji="ğŸ–¤">ğŸ–¤</span>
  <span class="emoji" data-emoji="ğŸ¤">ğŸ¤</span>
  <span class="emoji" data-emoji="ğŸ¤">ğŸ¤</span>
  <span class="emoji" data-emoji="ğŸ’”">ğŸ’”</span>
  <span class="emoji" data-emoji="â£ï¸">â£ï¸</span>
  <span class="emoji" data-emoji="ğŸ’•">ğŸ’•</span>
  <span class="emoji" data-emoji="ğŸ’">ğŸ’</span>
  <span class="emoji" data-emoji="ğŸ’“">ğŸ’“</span>
  <span class="emoji" data-emoji="ğŸ’—">ğŸ’—</span>
  <span class="emoji" data-emoji="ğŸ’–">ğŸ’–</span>
  <span class="emoji" data-emoji="ğŸ’˜">ğŸ’˜</span>
  <span class="emoji" data-emoji="ğŸ’">ğŸ’</span>
  <span class="emoji" data-emoji="â­">â­</span>
  <span class="emoji" data-emoji="ğŸŒŸ">ğŸŒŸ</span>
  <span class="emoji" data-emoji="âœ¨">âœ¨</span>
  <span class="emoji" data-emoji="âš¡">âš¡</span>
  <span class="emoji" data-emoji="ğŸ’¥">ğŸ’¥</span>
  <span class="emoji" data-emoji="ğŸ’«">ğŸ’«</span>
  <span class="emoji" data-emoji="ğŸ”¥">ğŸ”¥</span>
  <span class="emoji" data-emoji="ğŸŒˆ">ğŸŒˆ</span>
  <span class="emoji" data-emoji="â˜€ï¸">â˜€ï¸</span>
  <span class="emoji" data-emoji="ğŸŒ¤ï¸">ğŸŒ¤ï¸</span>
  <span class="emoji" data-emoji="â˜ï¸">â˜ï¸</span>
  <span class="emoji" data-emoji="ğŸŒ™">ğŸŒ™</span>
  </div>
  </div>
  </div>
  <input type="text" id="messageInput" placeholder="Type a message...">
 <button id="sendMessage">Send</button>
  </div>
 </div>
 </div>
 
 <!-- Members Sidebar (Right) -->
 <div class="members-sidebar" id="membersSidebar">
 <h3>MEMBERS</h3>
 <div id="membersList" class="members-section"></div>
 </div>
 </div>

 <!-- Add Member Popup -->
 <div id="addMemberPopUp" class="popUp">
 <div class="popUp-content">
 <span class="close-button" id="closeAddMemberPopUp">&times;</span>
 <h2>Add Member</h2>
 <input type="text" id="memberUsernameInput" placeholder="Enter username">
 <button id="confirmAddMember">Add Member</button>
 </div>
 </div>

 <!-- Create Server Popup -->
 <div id="createServerPopUp" class="popUp">
 <div class="popUp-content">
 <span class="close-button" id="closeCreateServerPopUp">&times;</span>
 <h2>Create Server</h2>
 <input type="text" id="serverNameInput" placeholder="Enter server name">
 <button id="confirmCreateServer">Create Server</button>
 </div>
 </div>

 <!-- Create Channel Popup -->
 <div id="createChannelPopUp" class="popUp">
 <div class="popUp-content">
 <span class="close-button" id="closeCreateChannelPopUp">&times;</span>
 <h2>Create Channel</h2>
 <input type="text" id="channelNameInput" placeholder="Enter channel name">
 <div class="channel-type-selection" style="margin: 15px 0; text-align: left;">
  <p style="margin-bottom: 10px;">Channel Type:</p>
  <div style="display: flex; gap: 20px;">
    <label style="display: flex; align-items: center; cursor: pointer;">
      <input type="radio" name="channelType" value="public" checked>
      <span style="margin-left: 8px;">Public</span>
    </label>
    <label style="display: flex; align-items: center; cursor: pointer;">
      <input type="radio" name="channelType" value="private">
      <span style="margin-left: 8px;">Private</span>
    </label>
  </div>
  <p style="font-size: 12px; color: #666; margin-top: 8px;">
    Public: All members can access<br>
    Private: Only allowed members can access
  </p>
 </div>
 <button id="confirmCreateChannel">Create Channel</button>
 </div>
 </div>

 <button id="logoutButton">Logout</button>
 
 <!-- JS Files -->
 <script src="./settings.js"></script>

 <script type="module">
 import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-app.js";
 import { getDatabase, ref, push, set, get, onChildAdded, off, remove, onValue, update } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-database.js";
 import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-auth.js";
 
 const firebaseConfig = {
 apiKey: "AIzaSyDFhghmxUfCJbnnOFsleHoatF7D-ubnLpU",
 authDomain: "project-8042491080443698183.firebaseapp.com",
 databaseURL: "https://project-8042491080443698183-default-rtdb.firebaseio.com",
 projectId: "project-8042491080443698183",
 storageBucket: "project-8042491080443698183.appspot.com",
 messagingSenderId: "583304911847",
 appId: "1:583304911847:web:8dfe3e5c016062dd457b42"
 };
 
 const app = initializeApp(firebaseConfig);
 const db = getDatabase(app);
 const auth = getAuth(app);
 const userRoleCache = {};
 const channelAccessCache = {};

 
 let currentUser = null;
 let selectedServer = null;
 let selectedChannel = null;

// Emoji picker functionality
const emojiButton = document.getElementById("emojiButton");
 const emojiPicker = document.getElementById("emojiPicker");
 const emojiTabs = document.querySelectorAll(".emoji-tab");
 const emojis = document.querySelectorAll(".emoji");
 const messageInput = document.getElementById("messageInput");
 
 // Toggle emoji picker
 emojiButton.addEventListener("click", function() {
 emojiPicker.style.display = emojiPicker.style.display === "none" ? "block" : "none";
 });
 
 // Tab switching
 emojiTabs.forEach(tab => {
 tab.addEventListener("click", function() {
 // Remove active class from all tabs
 emojiTabs.forEach(t => t.classList.remove("active"));
 
 // Add active class to clicked tab
 this.classList.add("active");
 
 // Hide all categories
 document.querySelectorAll(".emoji-category").forEach(category => {
 category.classList.remove("active");
 });
 
 // Show selected category
 const categoryId = this.getAttribute("data-category");
 document.getElementById(categoryId).classList.add("active");
 
 // Log for debugging
 console.log(`Showing emoji category: ${categoryId}`);
 });
 });
 
 // Initialize emoji tabs - ensure first tab is active by default
 document.querySelector(".emoji-tab[data-category='smileys']").click();
 
 // Emoji selection
 emojis.forEach(emoji => {
 emoji.addEventListener("click", function() {
 const emojiChar = this.getAttribute("data-emoji");
 
 // Insert emoji at cursor position
 const cursorPosition = messageInput.selectionStart;
 const textBefore = messageInput.value.substring(0, cursorPosition);
 const textAfter = messageInput.value.substring(cursorPosition);
 
 messageInput.value = textBefore + emojiChar + textAfter;
 
 // Set cursor position after inserted emoji
 messageInput.focus();
 messageInput.selectionStart = cursorPosition + emojiChar.length;
 messageInput.selectionEnd = cursorPosition + emojiChar.length;
 
 // Hide emoji picker after selection
 emojiPicker.style.display = "none";
 });
 });
 
 // Close emoji picker if clicked outside
 document.addEventListener("click", function(event) {
 if (!emojiPicker.contains(event.target) && event.target !== emojiButton) {
 emojiPicker.style.display = "none";
 }
 });

 
 // DOM Elements for Server & Channel Views
 const serverSectionView = document.getElementById("serverSectionView");
 const channelSectionView = document.getElementById("channelSectionView");
 const membersSidebar = document.getElementById("membersSidebar");
 const backToServersBtn = document.getElementById("backToServers");
 const currentServerNameEl = document.getElementById("currentServerName");
 
 // Initialize UI state
 function initializeUIState() {
   serverSectionView.style.display = "block";
   channelSectionView.style.display = "none";
   membersSidebar.style.display = "none";
   document.getElementById("chatChannelName").textContent = "Select a server and channel to chat";
   document.getElementById("messageInput").disabled = true;
 }
 
 onAuthStateChanged(auth, async (user) => {
 if (user) {
 currentUser = user;
 const userRef = ref(db, `users/${user.uid}`);
 const snapshot = await get(userRef);
 if (snapshot.exists()) {
 currentUser.username = snapshot.val().username;
 }
 console.log("âœ… Logged in as:", currentUser.username);
 loadServers();
 initializeUIState();
 // Start listening for access requests
 listenForAccessRequests();
 } else {
 console.error("âŒ No user detected. Redirecting...");
 window.location.href = "../LoginPage/user_login.html";
 }
 });
 
 // Get the current user's role in a server
 async function getCurrentUserRole(serverId, userId) {
  const cacheKey = `${serverId}-${userId}`;
  
  // Return from cache if available
  if (userRoleCache[cacheKey]) {
    return userRoleCache[cacheKey];
  }
  
  // Otherwise fetch from database
  if (!serverId || !userId) return "member";
  
  try {
    // Check if user is server creator (owner)
    const serverRef = ref(db, `servers/${serverId}`);
    const serverSnapshot = await get(serverRef);
    
    if (serverSnapshot.exists()) {
      const server = serverSnapshot.val();
      if (server.createdBy === userId) {
        userRoleCache[cacheKey] = "owner";
        return "owner";
      }
    }
    
    // Check role in members
    const memberRef = ref(db, `servers/${serverId}/members/${userId}`);
    const snapshot = await get(memberRef);
    
    if (!snapshot.exists()) {
      userRoleCache[cacheKey] = "member";
      return "member";
    }
    
    const memberData = snapshot.val();
    
    if (typeof memberData === "object" && memberData.role) {
      userRoleCache[cacheKey] = memberData.role;
      return memberData.role;
    }
    
    userRoleCache[cacheKey] = "member";
    return "member";
  } catch (error) {
    console.error("Error getting user role:", error);
    return "member";
  }
}

 
 // Update UI based on user role
 function updateUIBasedOnRole(role) {
    console.log("Current user role:", role);

    const createChannelBtn = document.getElementById("createChannel");
    const deleteChannelBtn = document.getElementById("deleteChannel");
    const deleteServerBtn = document.getElementById("deleteServer");
    const manageMembersBtn = document.getElementById("manageMembers");
    const addMemberBtn = document.getElementById("addMember");
    const manageChannelAccessBtn = document.getElementById("manageChannelAccess");
    const leaveServerBtn = document.getElementById("leaveServer");
    const settingsButton = document.getElementById("settingsButton");
    
    // Settings button should always be visible regardless of role
    settingsButton.style.display = "block";
    
    // Dropdown menu buttons visibility based on role
    createChannelBtn.style.display = (role === "admin" || role === "owner") ? "block" : "none";
    deleteChannelBtn.style.display = (role === "admin" || role === "owner") ? "block" : "none";
    deleteServerBtn.style.display = role === "owner" ? "block" : "none";
    manageMembersBtn.style.display = (role === "admin" || role === "owner") ? "block" : "none";
    manageChannelAccessBtn.style.display = (role === "admin" || role === "owner") ? "block" : "none";
    
    // Show add member button for all roles (now that regular members can add members)
    addMemberBtn.style.display = "block";
    
    // Leave server button is available for all except the owner (owner must transfer ownership first)
    leaveServerBtn.style.display = role !== "owner" ? "block" : "none";
 }
 
 // Updated function to show appropriate dropdown options for regular members
 function updateDropdownForRegularMembers(role) {
    if (role === "member") {
        // Get all dropdown buttons
        const settingsOptions = document.querySelectorAll("#settingsDropdown button");
        
        // Hide all options initially
        settingsOptions.forEach(option => {
            option.style.display = "none";
        });
        
        // Show options for regular members
        document.getElementById("addMember").style.display = "block"; // Allow regular members to add new members
        document.getElementById("leaveServer").style.display = "block"; // Allow members to leave the server
    }
 }
 
 // Function to grant all members access to the general channel
 async function grantGeneralChannelAccess(serverId) {
  try {
    console.log("Granting all members access to general channel...");
    
    // Get all members in the server
    const membersRef = ref(db, `servers/${serverId}/members`);
    const membersSnapshot = await get(membersRef);
    
    if (!membersSnapshot.exists()) {
      console.log("No members found in server");
      return;
    }
    
    // Find the general channel
    const channelsRef = ref(db, `servers/${serverId}/channels`);
    const channelsSnapshot = await get(channelsRef);
    
    if (!channelsSnapshot.exists()) {
      console.log("No channels found in server");
      return;
    }
    
    let generalChannelId = null;
    channelsSnapshot.forEach((channelSnap) => {
      const channel = channelSnap.val();
      if (channel.name === "general") {
        generalChannelId = channelSnap.key;
      }
    });
    
    if (!generalChannelId) {
      console.log("General channel not found");
      return;
    }
    
    console.log("Found general channel:", generalChannelId);
    
    // Add all members to allowed members of general channel
    const allowedMembersRef = ref(db, `servers/${serverId}/channels/${generalChannelId}/allowedMembers`);
    
    const updates = {};
    membersSnapshot.forEach((memberSnap) => {
      const memberId = memberSnap.key;
      updates[memberId] = true;
    });
    
    await set(allowedMembersRef, updates);
    console.log("All members granted access to general channel");
    
    // Clear access cache for this channel
    membersSnapshot.forEach((memberSnap) => {
      const memberId = memberSnap.key;
      clearChannelAccessCache(serverId, generalChannelId, memberId);
    });
    
  } catch (error) {
    console.error("Error granting general channel access:", error);
  }
}

 // Function to load and display members for the current server
 async function loadServerMembers(serverId) {
  const membersList = document.getElementById("membersList");
  membersList.innerHTML = "";
  
  try {
    const membersRef = ref(db, `servers/${serverId}/members`);
    
    // Use onValue to listen for changes in the members list
    onValue(membersRef, async (snapshot) => {
      membersList.innerHTML = "";
      
      if (!snapshot.exists()) {
        membersList.innerHTML = "<p style='color: #aaa; text-align: center;'>No members found.</p>";
        return;
      }
      
      // Get server data to identify owner
      const serverRef = ref(db, `servers/${serverId}`);
      const serverSnapshot = await get(serverRef);
      const server = serverSnapshot.val();
      
      const members = [];
      
      snapshot.forEach((memberSnap) => {
        const memberId = memberSnap.key;
        const memberData = memberSnap.val();
        
        // Extract username and role
        let username = memberData;
        let role = "member";
        
        if (typeof memberData === "object") {
          username = memberData.username || "Unknown";
          role = memberData.role || "member";
        }
        
        // For owner role, check if this member is the creator
        if (memberId === server.createdBy) {
          role = "owner";
        }
        
        members.push({
          id: memberId,
          username,
          role
        });
      });
      
      // Sort members by role: owner first, then admins, then regular members
      members.sort((a, b) => {
        const roleOrder = { owner: 0, admin: 1, member: 2 };
        return roleOrder[a.role] - roleOrder[b.role];
      });
      
      // Display members
      members.forEach(member => {
        const memberItem = document.createElement("div");
        memberItem.className = "member-item";
        
        const memberName = document.createElement("span");
        memberName.className = "member-name";
        memberName.textContent = member.username;
        
        const memberRole = document.createElement("span");
        memberRole.className = `member-role role-${member.role}`;
        memberRole.textContent = member.role;
        
        memberItem.appendChild(memberName);
        memberItem.appendChild(memberRole);
        membersList.appendChild(memberItem);
      });
    });
  } catch (error) {
    console.error("Error loading members:", error);
    membersList.innerHTML = "<p style='color: red; text-align: center;'>Error loading members.</p>";
  }
 }

 // Load servers from database
 async function loadServers() {
 const serverList = document.getElementById("serverList");
 serverList.innerHTML = "";
 try {
 const serversRef = ref(db, "servers");
 const snapshot = await get(serversRef);
 if (snapshot.exists()) {
 const servers = [];
 snapshot.forEach((childSnapshot) => {
 const server = {
 id: childSnapshot.key,
 ...childSnapshot.val()
 };
 if (server.members && (server.members[currentUser.uid] || 
 (typeof server.members[currentUser.uid] === 'object' && 
 server.members[currentUser.uid].username))) {
 servers.push(server);
 }
 });
 displayServers(servers);
 } else {
 serverList.innerHTML = "<p>No servers found.</p>";
 }
 } catch (error) {
 console.error("âŒ Error loading servers:", error);
 }
 }
 
 // Display servers in the server list
 function displayServers(servers) {
 const serverList = document.getElementById("serverList");
 serverList.innerHTML = servers.length === 0 
 ? "<p>No servers available. Create one!</p>"
 : "";
 
 servers.forEach(server => {
 const serverDiv = document.createElement("div");
 serverDiv.className = "server";
 serverDiv.textContent = server.name;
 serverDiv.addEventListener("click", () => selectServer(server));
 serverList.appendChild(serverDiv);
 });
 }
 
 // Select a server
 async function selectServer(server) {
  selectedServer = server;
  currentServerNameEl.textContent = server.name;
  
  // Switch to channel view and show members sidebar
  serverSectionView.style.display = "none";
  channelSectionView.style.display = "flex";
  membersSidebar.style.display = "flex";
  
  // Make selectedServer available globally
  window.selectedServer = server;
  
  // Check user role and update UI accordingly
  const userRole = await getCurrentUserRole(server.id, currentUser.uid);
  updateUIBasedOnRole(userRole);
  
  // Update dropdown options for regular members if needed
  updateDropdownForRegularMembers(userRole);
  
  // Explicitly ensure settings button is visible regardless of role
  document.getElementById("settingsButton").style.display = "block";
  
  try {
    console.log("Starting server setup sequence...");
    
    // Fix channel types first
    await fixChannelTypes(server.id);
    console.log("Channel types fixed, proceeding to access grants...");
    
    // Then grant access to general channel
    await grantGeneralChannelAccess(server.id);
    console.log("General channel access granted, proceeding to public channels...");
    
    // Finally grant access to all public channels
    await grantPublicChannelAccess(server.id);
    console.log("Public channel access granted, sequence complete");
    
    // Load members for this server
    await loadServerMembers(server.id);
    
    // Load channels for this server
    await loadChannels(server.id);
  } catch (error) {
    console.error("Error in server setup sequence:", error);
  }
}
 
 // Modify the loadChannels function to ensure type property is preserved
async function loadChannels(serverId) {
  const channelList = document.getElementById("channelList");
  channelList.innerHTML = "";
  try {
    const channelsRef = ref(db, `servers/${serverId}/channels`);
    const snapshot = await get(channelsRef);
    
    if (snapshot.exists()) {
      const channels = [];
      
      snapshot.forEach((childSnapshot) => {
        const channel = {
          id: childSnapshot.key,
          ...childSnapshot.val()
        };
        
        // Ensure type property exists (default to public if not specified)
        if (!channel.type) {
          channel.type = "public";
        }
        
        // Add all channels regardless of access
        channels.push(channel);
      });
      
      console.log("Channels loaded:", channels);
      displayChannels(channels);
    } else {
      console.log("No channels found for server:", serverId);
      channelList.innerHTML = "<p>No channels found in this server.</p>";
    }
  } catch (error) {
    console.error("âŒ Error loading channels:", error);
    channelList.innerHTML = "<p>Error loading channels.</p>";
  }
}
 
// Display channels in the channel list
async function displayChannels(channels) {
  const channelList = document.getElementById("channelList");
  channelList.innerHTML = channels.length === 0 
    ? "<p>No channels available.</p>"
    : "";
  
  for (const channel of channels) {
    const channelDiv = document.createElement("div");
    channelDiv.className = "channel";
    
    // Create a container for channel name and type badge
    const channelInfoDiv = document.createElement("div");
    channelInfoDiv.className = "channel-info";
    
    // Channel name
    const channelNameSpan = document.createElement("span");
    channelNameSpan.textContent = channel.name;
    
    // Channel type badge
    const typeBadge = document.createElement("span");
    typeBadge.className = "channel-type-badge";
    
    if (channel.type === "private") {
      typeBadge.textContent = "ğŸ”’ Private";
      typeBadge.classList.add("badge-private");
    } else {
      typeBadge.textContent = "Public";
      typeBadge.classList.add("badge-public");
    }
    
    channelInfoDiv.appendChild(channelNameSpan);
    channelInfoDiv.appendChild(typeBadge);
    
    channelDiv.appendChild(channelInfoDiv);
    
    // Check if user has access to this channel
    const hasAccess = await canAccessChannel(selectedServer.id, channel.id, currentUser.uid);
    
    // If channel is public OR user has access, allow normal joining
    if (channel.type === "public" || hasAccess) {
      channelDiv.addEventListener("click", () => joinChannel(channel));
    } 
    // Only for private channels without access, show request access button
    else if (channel.type === "private" && !hasAccess) {
      // Check if user already has a pending request
      const pendingRequestRef = ref(db, `accessRequests/${selectedServer.id}/${channel.id}/${currentUser.uid}`);
      const pendingRequestSnapshot = await get(pendingRequestRef);
      const hasPendingRequest = pendingRequestSnapshot.exists();
      
      const requestAccessBtn = document.createElement("button");
      requestAccessBtn.className = "request-access-btn";
      
      if (hasPendingRequest) {
        requestAccessBtn.textContent = "Request Pending";
        requestAccessBtn.style.backgroundColor = "#9e9e9e";
        requestAccessBtn.disabled = true;
      } else {
        requestAccessBtn.textContent = "Request Access";
      }
      
      requestAccessBtn.addEventListener("click", (event) => {
        event.stopPropagation(); // Prevent channel selection when clicking the button
        
        if (!hasPendingRequest) {
          requestChannelAccess(selectedServer.id, channel.id, channel.name);
        }
      });
      
      channelDiv.appendChild(requestAccessBtn);
      
      // Add click event to show access denied message
      channelDiv.addEventListener("click", () => {
        const messagesDiv = document.getElementById("messages");
        document.getElementById("chatChannelName").textContent = `#${channel.name} (${selectedServer.name})`;
        document.getElementById("messageInput").disabled = true;
        
        messagesDiv.innerHTML = `
          <div style="text-align: center; padding: 20px; color: #ff0000;">
            <h3>You don't have access to this channel</h3>
            <p>This is a private channel. Please request access or ask a server admin to grant you access.</p>
          </div>
        `;
      });
    }
    
    channelList.appendChild(channelDiv);
  }
}
 
// Added debugging to canAccessChannel
async function canAccessChannel(serverId, channelId, userId) {
  const cacheKey = `${serverId}-${channelId}-${userId}`;
  
  // Return from cache if available
  if (channelAccessCache[cacheKey] !== undefined) {
    return channelAccessCache[cacheKey];
  }
  
  try {
    const channelRef = ref(db, `servers/${serverId}/channels/${channelId}`);
    const channelSnapshot = await get(channelRef);
    
    if (!channelSnapshot.exists()) {
      channelAccessCache[cacheKey] = false;
      return false;
    }
    
    const channel = channelSnapshot.val();
    console.log(`Channel access check - ${channel.name} type:`, channel.type);
    
    // Owners and admins always have access
    const userRole = await getCurrentUserRole(serverId, userId);
    if (userRole === "owner" || userRole === "admin") {
      channelAccessCache[cacheKey] = true;
      return true;
    }
    
    // If channel is public, all members have access by default
    if (channel.type === "public") {
      console.log(`Public channel ${channel.name}: granting access`);
      channelAccessCache[cacheKey] = true;
      return true;
    }
    
    // For private channels, check allowedMembers
    const allowedRef = ref(db, `servers/${serverId}/channels/${channelId}/allowedMembers/${userId}`);
    const allowedSnapshot = await get(allowedRef);
    const hasAccess = allowedSnapshot.exists();
    
    channelAccessCache[cacheKey] = hasAccess;
    return hasAccess;
  } catch (error) {
    console.error("Error checking channel access:", error);
    return false;
  }
}

 // Request access to a channel
 async function requestChannelAccess(serverId, channelId, channelName) {
   try {
     const requestRef = ref(db, `accessRequests/${serverId}/${channelId}/${currentUser.uid}`);
     await set(requestRef, {
       username: currentUser.username,
       requestedAt: Date.now(),
       status: "pending"
     });
     
     alert(`âœ… Access request sent for #${channelName}`);
     
     // Refresh channel list to update the button
     loadChannels(serverId);
   } catch (error) {
     console.error("Error requesting access:", error);
     alert("âŒ Failed to request access. Please try again.");
   }
 }
 
 // Listen for access requests if user is admin or owner
 function listenForAccessRequests() {
   // Clear any existing notification elements
   const existingNotifications = document.querySelectorAll('.access-request-notification');
   existingNotifications.forEach(notification => notification.remove());
   
   auth.onAuthStateChanged(async user => {
     if (!user) return;
     
     // Get all servers where the user is admin or owner
     const serversRef = ref(db, 'servers');
     const serversSnapshot = await get(serversRef);
     
     if (!serversSnapshot.exists()) return;
     
     serversSnapshot.forEach(async serverSnap => {
       const serverId = serverSnap.key;
       const server = serverSnap.val();
       
       // Check if user is admin or owner of this server
       const userRole = await getCurrentUserRole(serverId, user.uid);
       if (userRole !== 'admin' && userRole !== 'owner') return;
       
       // Listen for access requests for this server
       const requestsRef = ref(db, `accessRequests/${serverId}`);
       onValue(requestsRef, async snapshot => {
         if (!snapshot.exists()) return;
         
         snapshot.forEach(channelSnap => {
           const channelId = channelSnap.key;
           
           // Get channel name
           get(ref(db, `servers/${serverId}/channels/${channelId}`)).then(channelDataSnap => {
             if (!channelDataSnap.exists()) return;
             
             const channelName = channelDataSnap.val().name;
             
             // Process each request
             channelSnap.forEach(requestSnap => {
               const userId = requestSnap.key;
               const request = requestSnap.val();
               
               // Only show pending requests
               if (request.status === 'pending') {
                 showAccessRequestNotification(serverId, channelId, userId, server.name, channelName, request.username);
               }
             });
           });
         });
       });
     });
   });
 }
 
 // Show notification for access request
 function showAccessRequestNotification(serverId, channelId, userId, serverName, channelName, username) {
   // Check if notification already exists for this request
   const existingNotification = document.getElementById(`notification-${serverId}-${channelId}-${userId}`);
   if (existingNotification) return;
   
   const notification = document.createElement('div');
   notification.className = 'access-request-notification';
   notification.id = `notification-${serverId}-${channelId}-${userId}`;
   
   notification.innerHTML = `
     <div>
       <strong>${username}</strong> requested access to <strong>#${channelName}</strong> in <strong>${serverName}</strong>
     </div>
     <div class="notification-buttons">
       <button class="access-approve-btn">Approve</button>
       <button class="access-deny-btn">Deny</button>
     </div>
   `;
   
   // Add event listeners
   notification.querySelector('.access-approve-btn').addEventListener('click', async () => {
     try {
       // Grant access
       await set(ref(db, `servers/${serverId}/channels/${channelId}/allowedMembers/${userId}`), true);
       
       // Update request status
       await update(ref(db, `accessRequests/${serverId}/${channelId}/${userId}`), {
         status: 'approved',
         resolvedAt: Date.now()
       });
       
       notification.remove();
     } catch (error) {
       console.error('Error approving access:', error);
       alert('âŒ Failed to approve access.');
     }
   });
   
   notification.querySelector('.access-deny-btn').addEventListener('click', async () => {
     try {
       // Update request status
       await update(ref(db, `accessRequests/${serverId}/${channelId}/${userId}`), {
         status: 'denied',
         resolvedAt: Date.now()
       });
       
       notification.remove();
     } catch (error) {
       console.error('Error denying access:', error);
       alert('âŒ Failed to deny access.');
     }
   });
   
   document.body.appendChild(notification);
 }
 
 // Join a channel
async function joinChannel(channel) {
  selectedChannel = channel;
  window.selectedChannel = channel;
  
  // Check if user has access before loading messages
  const hasAccess = await canAccessChannel(selectedServer.id, channel.id, currentUser.uid);
  
  document.getElementById("chatChannelName").textContent = `#${channel.name} (${selectedServer.name})`;
  document.getElementById("messageInput").disabled = !hasAccess;
  
  if (!hasAccess) {
    const messagesDiv = document.getElementById("messages");
    
    // Different message for private vs public channels
    if (channel.type === "private") {
      messagesDiv.innerHTML = `<div style="text-align: center; padding: 20px; color: #ff0000;">
        <h3>You don't have access to this private channel</h3>
        <p>Please request access or ask a server admin to grant you access.</p>
      </div>`;
    } else {
      messagesDiv.innerHTML = `<div style="text-align: center; padding: 20px; color: #ff0000;">
        <h3>You don't have access to this channel</h3>
        <p>Please ask a server admin to grant you access.</p>
      </div>`;
    }
    return;
  }
  
  loadMessages();
}
 
 // Load messages for a channel
 async function loadMessages() {
  const messagesDiv = document.getElementById("messages");
  messagesDiv.innerHTML = "";

  if (!selectedServer || !selectedChannel) {
    return;
  }

  const messagesRef = ref(db, `servers/${selectedServer.id}/channels/${selectedChannel.id}/messages`);
  const userRole = await getCurrentUserRole(selectedServer.id, currentUser.uid);
  const canDeleteAnyMessage = userRole === "admin" || userRole === "owner";

  off(messagesRef); // Remove any existing listeners

  onChildAdded(messagesRef, (snapshot) => {
    const messageId = snapshot.key;
    const message = snapshot.val();

    // Message Container
    const messageElement = document.createElement("div");
    messageElement.className = `message ${message.senderId === currentUser.uid ? "sent" : "received"}`;
    messageElement.setAttribute("data-message-id", messageId);

    // Message Wrapper
    const messageWrapper = document.createElement("div");
    messageWrapper.className = "message-wrapper";

    // Profile Picture
    const profilePic = document.createElement("img");
    profilePic.className = "profile-pic";
    profilePic.src = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAkGBxMTEhUTExMVFhUXGBUVFhcXFRoYFxYWFxUXGBUWFhgYHiggGBomGxYVITEhJSkrLi4uFx8zODMtNygtLi0BCgoKDg0OGxAQGy8lICYtLS8tLS0tLS0tLS0tLS0tLS0tLS0tLS0vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLf/AABEIAKgBKwMBIgACEQEDEQH/xAAcAAACAwEBAQEAAAAAAAAAAAADBAECBQAGBwj/xAA9EAABAgQFAQYEBQQBAgcAAAABAhEAAyExBBJBUWFxBRMigZGhBhSx8DJCwdHhB1Ji8YIjMxUWU3KSssL/xAAaAQADAQEBAQAAAAAAAAAAAAAAAQIDBAUG/8QAKBEAAgICAQQCAgIDAQAAAAAAAAECEQMSIRMxQVEEYRQiMoFS0fEj/9oADAMBAAIRAxEAPwBdE9UGC1HWDS8PDUvDR5rmj6eOASTKJ3gyMNxGhLw0MowkZvKa9JIzU4fiCpkxppw8EGHiHlDWKMxMmCpkw53EETKjN5UPhdhWXKgloN3MQUw1OJD2fkETEpSIuRFCmNVkiZPHJ+QoliIVKEUAbWLPFdVGXQmDWQNIVXNMNKS8CVh3g6qGvjsF36uInvVQQYUxPy5h7j6SQsuYdoXUgneNHuNzHGWmK2FqvCEEg7xZlQ2W2ir8QbIWr8IVZUSH3hnuydI4YNR0g3QnjkCT1ggA3gqezlbQeX2WrVoe5lLF9iwA3gqZfMOJ7NGpg6cEkbxWxk0l5EEpgqEmHhISNItk4h2ZOhJSBAlSRGjk6RUy+YLFwZplDaBL6RpmSN4qZCYB2jHmrOghObh1qj0ZlDaBqaEPZeEeZPZCzcx3/gnMehXMTvC5xCd4LDaRndlT5c9AXKWlQO1xwpJqD1jUl4WPinYXaM7CThNQXFlj8hH+Ww1fSPtvYuPl4mUmbKLg3GqTqCNDGGfC4c+D0Pj/ADeoqfDDIw3IgmQDWDd2IEpIf+Y5JG+1lAoQWWscxYFOwicw2gVEt34LBo4kRV+InLxDteiQZWICpXEHI4EDUkxLmkaRoAekUJhgoiUyjtE9RsvZCRPESCdofThztBkYfc+jRa2YPNFGejNoIIlK40HA0iipwG3rGqj7Zg8rfaIsJKt44YWD/Np4iq8ckRa1IbyvwC+U4ifk449qJgM7tYaPF8Ef+voZTgIKnBpG0Yyu11bExU9qzDYQ/wBQ6ednoBKSIlkx5s42adYqZ003UYN4IPxczPTFaRA1YtAjzhzm5MdkVvC6sR/gzfdm8e0E/bRVXaKdx6xhGQYj5aDrIr8D2zYX2qneBHtZO8ZvysXThDtB1vof4WNd5DZ7WgS+0zFRgjtFhgDC6sn4H+Ngj3YM9oqinzquYZGAifkYe0ydPjIUOLV9mKGcqHxgxuIn5YbwrmF4F2RlqKzAjLXG0cON4qcMmF+wdXF6PiWISoEZTZ8wN60e7+vPmbsztBcleaQRLWmhyvUXZQOlbGgvA8NMJq5Bbdgf28o6dICrl1MS5FKu5Y36x6rSqmeGm+6Pc9k/H7HLipYdw6pT0ejqSo+4PlHt+y+05E9OaStKxqxqOoNR5x8FKVmii60hw2os31i2G7VmSlAy1qQpiMyVFJBatiG/iOLJ8OMv48M7YfMnH+XKP0QH2iO7UY+dfD39RAuZKTiUlK0JyFYX4JiyUhBUgCijWoLVPAj2eG+KQqUZiZZmEJzZZYcqFfwu1aEAFqgijRxy+NKLpnTH5MZco1RJMT3cIfCXaff4dMwlTlSy6gzgzFEAPUgApTtRtI1lHrEvDXA45dlYEoG0VURtBVARQpGwjJ4S1JATN6RUzefrB6bCOpE9ORW8RYzT/lAypWx9YdiGEUsb8spZF6M9QVx9YGqSr7EakVJitPstZ34RlnBqO8cOzzGmTFFTRvD4XkOtN9kIp7Ni47NHEMKnjeBnECC4+x7ZWVHZ43i3ySd4qZ5ivemFtEqsvlhPlkx3dJ2gRJ3MdlPMLdD1l5YXInaKkJ4imQ8xPdnaH1BaL2WKhtHZhtFe6VtEGQrj1h7sNI+y/eDaO77iBfLneO7j/IQ9mLTGEM6BnERRaB/dAihO5h7MahD0GM7mKGdAilPMclQ2PrDv7Hp6QUTDFg8DE8CyfeOOKV/bBsvZDxz8Iux3Mc/WAGevYRXvZnEG8SXhyM+P4mUwCns5LbE+Fh6xeTKUUOAKuxpYH21jLkFR/CqqagGzaiGRjVBnagIs4vqLGPUalVI+ftHIQsTMpFvEBcbv15g/aFQTkBU6VFhRqsK9TraKLnlbkkv5AGrl30gc9Sk0NGpdqkOGNjpUbw7lQAkT0ig4vVtr+frGn2N2kJCncplqbOEVCmzEAp5JFAR7RlSUpfxBjZvqRRufMRafIVYBwXYuxfSJcea9iVpn2b+m2NM7DIyr8MtKZakABxMYKKnuxzNpUHz9cUGPlP8ARdeXFrSVMJkkgJoylIUkpN7hJmM26to+zGSAQCUuXYPUtdhq1I58uJ7cHdhypQVmcURQojYOFG0ZXYTzULUrSfipYoB4ZWImS0+yBGLxTNVmiCbgxBPBjXODER8sOsZvDP2Ws0DHKjtFSpUbKsMloH8sk8xDwT9lrPH0ZBCt4juSdY01YZIiplp0jPovyy1m9Gb8ryY75QcxoFMCnqShJWtSUpSCSVFgALkk2EHTRXWYp8sNjAcTNly0lSyAEtmJNns8eT+IPjoEFGEcm3ekMB/7Eke59I8YpRJJJJJLkmpPJMdUPgtq5cGL+Z/jyfT8L8Q4aYrKlYBJYZgUueCRGqQdhHxebNZhUmv2THo+w/i+bJGVY71NGzKOZPRVaNpF5PgpK4Ch8vmpH0SscIzcH8UYSZTvQgs7LGUWqMx8J9dI3Uy443FxdNHSssX2FCesVKusO90NxFTK4iXJjU0JuNojLxDRlRXuYWzKU0KlMQZcMFEQw2hcsvcB3PSOEkcQZxEPBo2HUB9yI7uhBC32IhhB0w3KZE8RzJ3iSOIpD1QX9kkCIpHEmK5zDoX9n53SqLPAolI5j6Gj5cbkzNHHnDCVeEG5DgW1c2+7QihUOyWNHpc9dIh8FJi2IHicEAWpzQs0OYZXhY1Z/UGh51hSdhiDqUs/TcRMiaQtjShJe5Yf6ipcrgBns7FlE1K0KUhWZJBBYpUFAhtiCkDzj7T8F/EKsXiMGlZPeSsLie8f8xz4VKJj7kFQPIVxHwrErs1NRSrio6Vj2HwB8SDCT0T1IUpPdrlLAbMApSSMoLVdCblmeFNcFJn2341xapWEVMQspyLkFSku4R38sTCGv4CqkeP/AKXfE0yfMXKXRKZapi9u+mYmbMJTqyhNIr/6Y5cnZ3xvhu0ZS8LigZJnNLSxcOspCEhX9+arkAfqT+kHZ0tGGmzhVcyYUKOmWU+RvNaj58RzSdRdmiVzR70YhP8AdHHEp3iC2w9IhSUm4Ec+7N6j9k/Mo3HpFgUnY+kDEtO0XSQKCFu/I2l4ImSAbACBKwmzekZXbXxfhMMDnmpUoEDu5ZCpnml6Ny1o+a/F39RJuJBlSAZMouCX/wCosckfgHA9dI0h8d5H2IebXyfRO3fijC4VBK5iVqsJcsgqOla+Ecn3NI+Q/EnxZiMYchZEt6S0OAXIbOSfGR5DiMNcxwEi2ghkyQG0pXcneO2GGGLl8sz2lk7PgoRloSKeppce8EwiiQNxl9HFfvmkJTnKxq9Gv5RoYZaczKBzUHBOwNdPrFT7WVj5lXgLNlW60PP39ICT+3NW/eL9oYsJNB4gA3m3r/EJYeQc2dbnM/DFy/ndoiCdWzTI1trEaw88EsCC1+Kt9Y9L8NfFK8OrLMK1StUO5TRwZbm1LPrHl5imDiuVz1S9RxT6PDMsBYcGhFDE5IRkuew4N3S7n13sPt6ViUuhwofiQSMydjS4NKiNBS4+Hdm9qGTNSUEpWkkg3YnQjUaNH03sX4+kqOXFITKVRlpBUhW7gAlHvHFl+I4u49jeOY9G4iUkvS8I9qfGWCkS0TCvMJgUqWEJJUphZm8JNvE31g3Y3xRhcSWlK8Q/KpJQryBv5WjHoyS2rgrrp8DisKvX6vC65SheNYrBiMw2idUNZZIxlJMd/wAT6xrqWNhAzMawELVF9RszUydTQesGRhUkUX7QyZiv7R6/xEJzf2pHMFINmIzsGoWUD7H3hdchYuPcRplK9ke8VmS1aBMHA1JmQVEXHtFTNH2I1TIVqERQ4bhMK0Oz84LwgIzJ1PhG4Ykke3rCuVr3jdwk2twEvp1+/SK9t4IJyq8SnJLkMwuLcx7Ky/tqzw6tWZaE7V41H7xcUH6RKUjgGjNc1tF8OvNUPQ1Ip1fiNKECmz3DBuedvpC0w/mJcg+1HY+lOYZm4ZQISAK81Nmfmum0BsbcVhqkIbRKC0EgEkHTQPSnpD8oAJBOVzQm9Nzt72gEmU34Rle2yjzXjfSHJc0h1OxpoTTYlq60IOkQ+SymYCir/idIDhrENQfbx6f4X+O52DwvcpkpmELUoKKlChPiCgBUuzHR6ilfKrNSlQv+ApSKs4I4PFIBICkkXBsOFM4cil2iZRT4Y02naP0Tgu25U2WiahRyrSFB710POkBxHxLh0KyrmAEh/dusfH+x/jJUqQqTNQtX5pRSwyklykuKAGoLHXYRkrmTJiiq7ualwH0BJdjHL+LzydT+QqVK2fVu0v6l4ZBUmUmZMIsWCUE9T4m5yx4Ltz4yxWJcKmFKC/8A05fhS2xaqv8AkTGR3YQMy67J3PPEVkz2UVKDkim3P6R148WOHMVZhNzlxJ0LZor3kaEzKsg5XOulOYkYVArl0cvcftrG3VXknot9nwTJoA21d6x2Vz6n2g6pQahZw7a/teBJS+o9WrGF2dNVwZ+IB7wAcNwbxp6ElgLs1m2hD5dSZtj4rHY8+jxtYfBEgPb9y8PJJUhYYttiSpbrCiNLGvit98mDTAcrEmwA/eC41AlrSh3LZjxX2hbHTc6SE2IP60jPmVGtqF2Y+HUoO1jfYjaNzCS0hRAJahbkj2H7mM3BoZJBarH0t7PSHOzmzKJJI3bXaNsvNmGFpNGVjHzKWS7ksehpaJ79QqDD0+UKuDeohNUoDy+6xcGmqZjNNO0AlzHUC1zWNDCYmgCvXfrzr5QgKGJykkFIJb7/AFi5RTJxzcT6H2D8bKRLyzlkpSKLqVAaJU1T1/3Fcb/UlanEhFd17C7JB+p8o8hg6pyta+3m/pAZeFCMwc1s/wCUfrt5RydLHbtHW5TaVPg9phP6hTmeahLf4khtNXjZwPxiiZ+bIdlKA9DYx82loUXArZh/rmHfkVBQBo4J9xT3iJYsfouLmz6bJ7azfhWFdFP9IYT2orePkoCpcwFKmIq433EeywXaGdAU70r11jN4Y+DRZH5PVjtY7xCu1+Y84cUYjv8AmI6ES1kZvq7VP9x9BAj2qr+4xid5zHZusHSh6DeR8fROh/5pa0CXmLXHBjITGjg5jEOKFw4vWO9xR46ZY4WtL+1ngktJFW2NSz8VsYYVMGpDaulyf2sIqhT0ctvu/tFDOICnelRVmbkt/N4RxUkhTmoOv780jRXLplQPFyaelGoRx9IjDKoM7Ei+ljcCj6berQABwfhH4gUk2D+FV6gB9B++53SssEhKnpVgdw1Gr+sDKBmBBIZTkpoRXawNIZn4pKwc0sKUCCFpYKNS2cA1JFXGrxL7lIrOnFPhYaDLXqcr1NxFDMSVB8wIJJBDcW3guGwiJz92AogZspLKYAX8NRmpSM/ESFpU34QB+YsoEAnIDqfanETUW/sNX3D4vD5ScpSrh2I9/eKSJpSTloBcHn+DEYadmUHFDRyLH7+sMSsis2UgEEOOSKUNw301hSToF7R0+bnINWGhb2g2CyOc99Nevn+8LpSUFJyuCzACrGwrUGsGnISbhwbXAvTatoak6orzbLrl+PMgNoRrle7Q+pFCHcb9LffEYycSoauNibX1vcwXC4tROUh3rS4PXeB8miyqI3L0zGtHbXcdIpiEl8yaDXQ39oJKmpqHyF7MS40/MwMcqeVJNDks7G+r9KwJohztHSZoVS3Us21erQTPNYtnDaupvIiBImAAuEl7PQ1qDUfTeCicpmZDdPrvC/ofUYmqWSXqTYnMDXQAm8DUCATUB2cjWtHMNzJhsQPL2jpQSC93ds1Ruz0rz7RopGT5Yvh0OXU5FN6/xrFTPJXQsmjdWq8aAzE0KePFmNbsHiJkhVWLByWym5a96UBbn0Nk2VtSoSx+JBbK4hYTOX3FjD3cqIJAZqnT2hXuSosdS7vTzN4cXFcETm5OyhnqYBgx3F+jxRCvy5mG7acDWGTIdgpRA0ckgE9A8QqRSjt69TakVsibAJmVABAYUNQL+ew9IblTVEMTbUg/U3gMwnUBn0SAfaDjKX8AHlUdXPXSIkkzSGSmNYefl8QZ+K21s+0WHbCqqVWhHP3+0Zs3EpDMyd3qDXZqeUGSCWKWO5S5B4IsfSM+mjb8l1wwq8SDXKdSS73H8QXs3tQykAAA3Jvqf5ECmBSmCpbchPrRw/XrAyU6ItYh3terw1FCecdn/FK02lp1d/axhlHxEvKFEIHrGMoOCzNsQ7+ZDe8KrGv4XNkinvSK0j5RPXkvJ6M/EKtW9DFP/MCuIwETl2KiRQ2D/d4jvFbGLWOPpGUvlTvhsyjh1DmCyVgDxCj+hgshRoCNRX99usXGGq5Uz60BNqEWP1hCDEgijF2qqgAI39OkQrALQQQo5QfENRQu7XF6j2gEzBlSaF9SygxHBD+8PLOUeFyA9MtSGYV/1aGBUlKvESHpqQ9+Gag6QRZs45Bvs/6RmKxjh1JANgzhq7RfCzspKbpy53vlLip4t7QAPAhL7MG1ozUPrS9fKKFJdwQRlIJ1fk2d26tFFIIYpIKKHnR20Pt6x2GxTEpKTpVteu0TJvuilXkmVhZ0pQXKS9iHNq1o7G+r+UMYvCKmETAbMQw8Od2Zmfa9I0jiSjKCXFOGFPWDInguH8FKM1Kvy9vsxyvO7ujRRXY80o5ci0nLmZkKAWpKgSwqA6Szg1vq0OS5QUpa2AzAE5nBCg4GWpCuRyIt2xg0gpUkWZQSCXDVcaHZmFS73iTKWpIUGKTUg/y/30EdF3GyezoJKQCfxMRqd9KCBITXxF3BZJIpZxTkP91EnHECsuhASSAFNWhSVVTTK9QDDSJqahqAAmxZ0u9DUMH8L0BNhTJpovhiqcOWYhi1djQv7v7QLI1/v7aGFzzmRQKlVzUqL63s21mjR7mVMSnLRRPiZIYVqAEJAsxiXLXuTrfYykTilJAUGuPCPreO71b1UrLQsKUewhhfZ+UsCli5balQQWeDy8IkHxF9NhToKikOWSEUTTDYWVLmFxRIAclQBsWAB1p7QtjE5FMKpd3ehB0UzQKS8pailikhq2D8mkaEkkkElIYGwYNlZyTrU7w9n3vgkWxCQwLpBprq2ZqnYiCCSVDNMN9Xqz6bVgWJmFxkBd7M4OrUEATiFh0qQoEGtKgnq/28DvwIMrBLfNLzKZnFzV9Bfye4iM89DBQUAQSHTodaj62i6wCyiVSyKDwqOaoqS4FXFGh44mZLYJKS6XWQ1qMCSQ9/ODfwwoWwOMWHAAVqrw8sAzMTU0beO7YxRQcqEpBBdglJcEbAUvB5OKYKZK0pKa5AhKX65f54hH5VS5nhKcySXYupNNQl3N/Q2iHKO1hzRCcWolImS2DADLQDclgSdIYxeOloskkmoFqHdoWmSaMM6zuUkVBY0NhYP0hafLUQywzM7myRTNv5RUWhcnHtFJPiQnKbkPmu7kk1g+Jw8tR/7mQf5AqfySKWjHyVZJzX00HmXFI1sIAUspKQkF3FTXTUlo1dIXcRXhwLKB5g8jwpKQpnu3SNHu5SvFVgQ4FMxazGw/iAT8MHJ/CGoCGL0oYFlXkNQMvEqSXK6WIv6ByHi8zHA1F61JJ9mrF/lJdPxLchIYEknVkiusTMMkeAoAymodvFapJfSHumOmIqxCi3jA3p9vBZuO08LM1EgdX6xIwqFlkqSDUmtPJzWJndnhAJKxxSp9CQPOG5QuhUy8nGgt+Cgo4NG0Y/V4uMWg1JS+tP5EAl9nlQJDuA4GQuekSOyF8Dqa+cTcE+4UzMCXJdh1obfe36QSTPBuoGrX5O9DxACotU60sfeAZ2IysKh2pbQiNRmiVFFHoHbhzWCpm06+/WEhOfX3jpc1tbRnJDQbGTH0BTmrQHhv5gGGkpXmASUgUdzYlmUeraG9oZzPUef8/ekXlBiTcb7HSp6RaYMDh5iqoJIZyliDoGAG14e7PkBJdRsXu9Bqdop8ukgrLPc00+jG/+4CtXhICmtlVd3e56N9vCmm1SGjRxuLYFvujV5p7wn8x4RblvusZ7zGykO9yKvqBSCYWYMwSacb8Rz9JJFXbPRSlJmIZZIBZwmiiW3F/PzeFsQRKUUpDpU4AuQ5o4GjnaKBaioDXpcuetP5gXxAgqIAUA2hfMeX1GnrE4U1KvBT7FSVhJJQl2ZQAo70zZnemnMJTU+OUMuT8WZq3HiLPpUNS0MS8ZNCmIChl/E9XAcEMRV2d76xeVOzVDuHoD65kvSgNjrqI6UiW/RGXMGSxLGlaNuOoeB4bFzUNkYFWrgsfEDQ020OkMzEMe88I1VTw9SkAtV9K0gE9CkliSoCxZ8oaoazOCb6nWJaGailGaE+KoZgaCt31ev3SFps5UtwoZupBLaMfu8AwGNbNJYFNWLeJJuWLOxAIIhrHqYIVmBpSrhiODcNfmMliV0xydqyi1Kawy0D6gPSFZeNXLcCoYht3JcHce0OTJ2cEBmYE1Aso1Twf32heUlLp0JJfo16xtHHFKqM2x/svtRGXKSUgBzmO/9rliOGhjEFE1i4DE1dNSAw51jCnofrq7P5b/AMwuUqBoaB2Ylj5fekZz+Ou8Q2fk1pkxYDKmEIIdAKgcwSS7vqGs2sN4dcoZVHKHZQdSQwY0bZ29IwziypSVEAgDKACpgGIe9DXSGDMQEghRoCGy0AdwxU+52vFLCqoWx6GVNExwVixAy60cDNZ+IyMUhInESUqGSpOYkqAAok/lJJFLVPEKLxzhKRPXlGhmMA22Uu1BFsViCt/+oAQAAQolwkJ1oRr6RjLBo7XYNrRIw89ZUCotUnMaopfMejecaMnCqnIUFsaKZQILh6PyGeF+yZRmJU6l7GrZizF6O/7wTClKpigFALFAMtg4ByMa3OkKbpDVA+z8JNlpICSQajMgGvS7Whib2bmDEKBo7ADyIBpRq7CBpxhUWSoC4YkhVNgzN91jsRjJlQJRIFyFgkPvVwf0inLI0NKKGFLynIgAZWDUDedr3rcGEZ3Zs5lKDCrsC7ktUMG19otLnzFKUUDKwfxAPamjk0FK11tCUvtQi6iQfQHX3gipXxQnXk0MPhJyC7oD0JCgFtYgG4PMXVghMckFBtWYVBRb/I1ve9TvCMzFEsScgJCg5d6s7XY7wwmavK6ikapFK3rA1LuNUM4rCKQ6ZQSKaJBB/wCZP6QtKw8wVWiugcBNPzEig9IiRiH/ABLAFr25I3iEsTmE1wbg0IA01eI5iqYcDiildiXIckF9dCawLv5QpmWf+RMKd7mPhcNy4pFDiFChyv5fvCjC+7K4MdK9jSn7wNUhVwKE7VFIlSCk0D9NfSLS/UXpHeZETgQG52rb6RABAg5JI8Jp/kHbdjtaIMpnUBZy1wPT7aACnfDo/wB6RcdoqdgAbMGfbztFcShw4vo1v4MDk5SM1X1o9R0s/wCkFDNDvkkByaA61a/8eUQZRopP/wBWBBNLfWFpKLgirmyt61fT94lEzxqSAfUADrStLtAB2ca+H1atww04gCUL7zwh2tlLA7ZTzBMZhGrUC5AAPoxaCdzUK0FQx20Id2p/qFQWFw3aikq8SKimpYjWprT6QactM0OFDMbijg9DUh4EogBwS1yWbfT7EKyUEuUl8wGyTUsS21FB3/aJ1SdorZsekTFZci0nMPwqzPZzlOyWtsYIuSXelADu5an1b/UBlpU4TlIalRdqAwX5oI8K8wJo4ZVB/ib6AW0OkOwoMVOkpUkVpYGnB9/KIOIXd07tWnnEdwUkqBGQ/hVlOwb9Pe8Aqx1/2bbGJqx8osspAdtcwP8Aa9zalYblYhKkgBLsSg+HgE5G68QmFmzOCGf9PaKyECWSzkElTHaxqLWhuNgpUOI7PCQwV4qKYUUEkkP0cN1ihkKSRZ2y1DNW7eYPpFJE0EleYg5coD5mIWVWVcVNiGb0bwExMxIcMoO9ahudCzUiXKSf0PWLXApOWnN4QdmNKhoiZKeqaAAOLtWre3+oZxsgpUfCx1cFw3PT6QustTUcG21/V41TszaoOjFqQfyqSS9RRrn1gk7tVI/CimhIA+kZvfCiSzCzAWf3+tolazlY1bxHVxVvK0TKCYWMYrFeJK0MXsSScpSzseTE4XEGcWJG5CnILH9HindpMtgWqVCmrMR6v6CEkhSC9hTzFvv+IaVITNmfPagJqw2YixaztGXNIWs6Fwcz+IktffrDKEOQaEFnbSlRXW3rA5uUiksC1W+pjJQSdoH9mgnM4YigBJLFqEEfXT1ik3DKUpKgQA71IVWj9RT3gUqeJYIosAXCQwD7s7ObxmJnqMxyoJvQhx0brEuNfxYJ+z0c0lAKUZWZIegFhcqLAPd9ooMCpSAFy0oGgzpvqosdYVwaDlLqcO+wIawfzgqcQ1SSDyxDNYNGH7Xwa0mEVLEp1EBbZbgEC9We9oBO7SzgKZKWLJdGbgni8VehXRROUsNLwj2jik5MqS1XbWt336wK26fcOEMYoCYSRkd65QEv66xX5ZVhLUNHa+7lozsBi8mZ3BahCm/SsaWH7SlN40Lf+5CxffKR/wDoR0xTSojhl0ykuQKEMXAGv8mArwhJJaXUm5AJ5MMSsQSXq1wokM2hN/SBqx6BQJSeQlDGJ88MdGNLmEG/6AwxhQlRoQDvoSd4iOjefZ0ShmZh8pJI8wS3MDMtrKPT3HDNHR0Z4ZucbY5KmdIDA+Fr9CAL/R4qcpY5agl2auoLinEdHRsSxQitHB4IF4bkTh/cSQQD4AGuxBc5qizDRo6OiWUg5kPmKSxNXJZ6uaa11rAJmGWBmyqFHGWzEs76j+Y6OihA1zyAyhqQfSnSkEwZpQOwLfqxYt1jo6E0Fle1CpwkEqSDRdgaUFdnPpw8OY6UFEKCXY/s7ua/fl0dCY0E7t1Ep/Ar8QGoCTl1sD6QNJFh7MQQDTxP+m8dHREeLKlzQVeFer3FGfe3TziniZlUs2vt6x0dCjLmhyRReDLBQo7gEhkki7HyMAxGKmNlWCAK0ppuL9S/nHR0OM7dClGg+AxZSC6iAbEb2exNL0rSHlT0LvRf1Y8UMdHQpJbAnwK4rDKukk/XnqLCKSkrIdIJ2DOxuWa1vpHR0JZnTfoNFdDPycxrtoOrV624gi+zfCshyeaAgF1ADSoFY6Ojn/Im6NOmkZeXItgxrYsRWjEGHRixMWAUpIN7keeUv5PHR0dWR1Db6M8UFKaj9jkvB4eUfGSomhS7AZiKc6MC8ehXOwsyXkUwHhd3pzmFh7Ujo6OV41NKz0YuKuOqr/v+jA7WwSELB7wZWcJdSgxZiFKNTqxfSMpWPYUQ6SPDR+qvdm+sTHRWJfqm3ZxfIioZHGIKbjVfmTlDAUGUcOG5NOTCSyV/lc6kAkk6O0dHRtBLuc7YOZhVCpHk9f8A43gQW1GPSOjo0HKKSs0U4IEeLM+iQRSv7ViFdlpf/uAcF382jo6MN34K1VH/2Q=="; // Placeholder before loading actual image
    profilePic.alt = `${message.senderName}'s profile picture`;

    // Fetch profile picture from Firebase
    const userRef = ref(db, `users/${message.senderId}/profilePicture`);
    get(userRef).then((snapshot) => {
      if (snapshot.exists() && snapshot.val()) {
        profilePic.src = snapshot.val(); // Set profile picture if found
      }
    });

    // Message Content Container
    const contentDiv = document.createElement("div");
    contentDiv.className = "message-content";

    // Username
    const headerDiv = document.createElement("div");
    headerDiv.className = "message-header";
    headerDiv.textContent = message.senderName;

    // Message Text
    const textDiv = document.createElement("div");
    textDiv.className = "message-text";
    textDiv.textContent = message.text;

    // Timestamp
    const timeDiv = document.createElement("div");
    timeDiv.className = "message-time";
    timeDiv.textContent = new Date(message.timestamp).toLocaleTimeString();

    // Append Content Elements
    contentDiv.appendChild(headerDiv);
    contentDiv.appendChild(textDiv);
    contentDiv.appendChild(timeDiv);

    // Append Profile Picture and Content
    messageWrapper.appendChild(profilePic);
    messageWrapper.appendChild(contentDiv);
    messageElement.appendChild(messageWrapper);

    // Delete Button (if allowed)
    if (canDeleteAnyMessage || message.senderId === currentUser.uid) {
      const deleteBtn = document.createElement("button");
      deleteBtn.className = "delete-btn";
      deleteBtn.innerHTML = "&times;";
      deleteBtn.setAttribute("data-message-id", messageId);

      deleteBtn.addEventListener("click", async (event) => {
        event.stopPropagation();
        if (confirm(`Are you sure you want to delete this message?`)) {
          try {
            await remove(ref(db, `servers/${selectedServer.id}/channels/${selectedChannel.id}/messages/${messageId}`));
            messageElement.remove();
          } catch (error) {
            console.error("Error deleting message:", error);
            alert("Failed to delete message.");
          }
        }
      });

      messageElement.appendChild(deleteBtn);
    }

    messagesDiv.appendChild(messageElement);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  });

  onChildRemoved(messagesRef, (snapshot) => {
    const messageId = snapshot.key;
    const messageElement = document.querySelector(`.message[data-message-id="${messageId}"]`);
    if (messageElement) {
      messageElement.remove();
    }
  });
}

 function clearUserRoleCache(serverId, userId) {
  const cacheKey = `${serverId}-${userId}`;
  delete userRoleCache[cacheKey];
}

function clearChannelAccessCache(serverId, channelId, userId) {
  const cacheKey = `${serverId}-${channelId}-${userId}`;
  delete channelAccessCache[cacheKey];
}

//fix existing channel types
async function fixChannelTypes(serverId) {
  try {
    console.log("Fixing channel types for server:", serverId);
    
    // Get all channels in the server
    const channelsRef = ref(db, `servers/${serverId}/channels`);
    const channelsSnapshot = await get(channelsRef);
    
    if (!channelsSnapshot.exists()) {
      console.log("No channels found in server");
      return;
    }
    
    let fixedCount = 0;
    const fixes = [];
    
    // Check each channel and collect fixes needed
    channelsSnapshot.forEach((channelSnap) => {
      const channelId = channelSnap.key;
      const channel = channelSnap.val();
      
      console.log(`Checking channel ${channel.name}, current type: ${channel.type || "not set"}`);
      
      if (!channel.type) {
        console.log(`Channel ${channel.name} needs type fix`);
        fixes.push({
          id: channelId,
          name: channel.name
        });
      }
    });
    
    // Apply fixes sequentially with await
    for (const fix of fixes) {
      console.log(`Fixing channel ${fix.name}: Setting type to public`);
      
      await update(ref(db, `servers/${serverId}/channels/${fix.id}`), {
        type: "public"
      });
      
      // Clear cache for this channel
      Object.keys(channelAccessCache).forEach(key => {
        if (key.includes(`${serverId}-${fix.id}`)) {
          delete channelAccessCache[key];
        }
      });
      
      fixedCount++;
    }
    
    console.log(`Fixed types for ${fixedCount} channels`);
  } catch (error) {
    console.error("Error fixing channel types:", error);
  }
}

async function grantPublicChannelAccess(serverId) {
  try {
    console.log("Granting access to public channels...");
    
    // Get all members in the server
    const membersRef = ref(db, `servers/${serverId}/members`);
    const membersSnapshot = await get(membersRef);
    
    if (!membersSnapshot.exists()) {
      console.log("No members found in server");
      return;
    }
    
    // Get all channels in the server
    const channelsRef = ref(db, `servers/${serverId}/channels`);
    const channelsSnapshot = await get(channelsRef);
    
    if (!channelsSnapshot.exists()) {
      console.log("No channels found in server");
      return;
    }
    
    // Log all channels for debugging
    console.log("All channels in server:");
    channelsSnapshot.forEach(channelSnap => {
      const channel = channelSnap.val();
      console.log(`- ${channel.name} (type: ${channel.type || "not set"})`);
    });
    
    // For each channel that is public, add all members to allowedMembers
    let updatedCount = 0;
    
    channelsSnapshot.forEach(async (channelSnap) => {
      const channelId = channelSnap.key;
      const channel = channelSnap.val();
      
      console.log(`Processing channel: ${channel.name}, type: ${channel.type || "not set"}`);
      
      if (channel.type === "public") {
        console.log(`Granting all members access to public channel: ${channel.name}`);
        
        const allowedMembersRef = ref(db, `servers/${serverId}/channels/${channelId}/allowedMembers`);
        
        const updates = {};
        membersSnapshot.forEach((memberSnap) => {
          const memberId = memberSnap.key;
          updates[memberId] = true;
        });
        
        await set(allowedMembersRef, updates); // Use set instead of update to replace any existing data
        updatedCount++;
        
        // Clear access cache for this channel
        Object.keys(channelAccessCache).forEach(key => {
          if (key.includes(`${serverId}-${channelId}`)) {
            delete channelAccessCache[key];
          }
        });
      }
    });
    
    console.log(`Updated access for ${updatedCount} public channels`);
  } catch (error) {
    console.error("Error granting public channel access:", error);
  }
}

 // Event listeners
 document.addEventListener("DOMContentLoaded", () => {
 const sendMessageBtn = document.getElementById("sendMessage");
 const messageInput = document.getElementById("messageInput");
 const createServerBtn = document.getElementById("createServer");
 const createChannelBtn = document.getElementById("createChannel");
 const deleteChannelBtn = document.getElementById("deleteChannel");
 
 // Allow sending message with Enter key
 messageInput.addEventListener("keydown", async (event) => {
  if (event.key === "Enter") {
    // Add the same access check as sendMessageBtn
    if (!selectedServer || !selectedChannel) return;
    
    try {
      const allowed = await canAccessChannel(
        selectedServer.id,
        selectedChannel.id,
        currentUser.uid
      );
      
      if (!allowed) {
        alert("âŒ You don't have access to this channel");
        return;
      }
      sendMessageBtn.click();
    } catch (error) {
      console.error("Error checking access:", error);
    }
  }
});
 
 // Server popup elements
 const createServerPopUp = document.getElementById("createServerPopUp");
 const closeCreateServerBtn = document.getElementById("closeCreateServerPopUp");
 const confirmCreateServerBtn = document.getElementById("confirmCreateServer");
 
 // Channel popup elements
 const createChannelPopUp = document.getElementById("createChannelPopUp");
 const closeCreateChannelBtn = document.getElementById("closeCreateChannelPopUp");
 const confirmCreateChannelBtn = document.getElementById("confirmCreateChannel");
 
 // Member management
 const addMemberBtn = document.getElementById("addMember");
 const manageMembersBtn = document.getElementById("manageMembers");
 const leaveServerBtn = document.getElementById("leaveServer");
 const addMemberPopUp = document.getElementById("addMemberPopUp");
 const closeAddMemberBtn = document.getElementById("closeAddMemberPopUp");
 const confirmAddMemberBtn = document.getElementById("confirmAddMember");
 
 // Back button
 backToServersBtn.addEventListener("click", () => {
 serverSectionView.style.display = "block";
 channelSectionView.style.display = "none";
 membersSidebar.style.display = "none";
 document.getElementById("messages").innerHTML = "";
 document.getElementById("chatChannelName").textContent = "Select a server and channel to chat";
 document.getElementById("messageInput").disabled = true;
 selectedServer = null;
 selectedChannel = null;
 window.selectedServer = null;
 window.selectedChannel = null;
 });
 
 // Send message
 sendMessageBtn.addEventListener("click", async () => {
    const messageText = messageInput.value.trim();
    if (!messageText || !selectedServer || !selectedChannel) return;

    try {
        // Check if user still has channel access
        const allowed = await canAccessChannel(
            selectedServer.id,
            selectedChannel.id,
            currentUser.uid
        );
        
        if (!allowed) {
            alert("âŒ You don't have access to this channel");
            return;
        }

        // Send message if access exists
        const messagesRef = ref(db, 
            `servers/${selectedServer.id}/channels/${selectedChannel.id}/messages`
            );
        await push(messagesRef, {
            text: messageText,
            senderId: currentUser.uid,
            senderName: currentUser.username,
            timestamp: Date.now()
        });
        messageInput.value = "";
    } catch (error) {
        console.error("âŒ Error sending message:", error);
        alert("Failed to send message");
    }
});

 // Create server
 createServerBtn.addEventListener("click", () => {
 createServerPopUp.style.display = "flex";
 });
 
 closeCreateServerBtn.addEventListener("click", () => {
 createServerPopUp.style.display = "none";
 });

 // Create channel
 createChannelBtn.addEventListener("click", async () => {
 if (!selectedServer) {
 alert("âŒ Please select a server first.");
 return;
 }
 
 // Check user role
 const userRole = await getCurrentUserRole(selectedServer.id, currentUser.uid);
 if (userRole !== "admin" && userRole !== "owner") {
 alert("âŒ Only admins and owners can create channels.");
 return;
 }
 
 createChannelPopUp.style.display = "flex";
 });
 
 closeCreateChannelBtn.addEventListener("click", () => {
 createChannelPopUp.style.display = "none";
 });
 
 confirmCreateServerBtn.addEventListener("click", async () => {
    const serverName = document.getElementById("serverNameInput").value.trim();
    if (!serverName) {
        alert("Please enter a server name.");
        return;
    }
    
    try {
        const serversRef = ref(db, "servers");
        const newServerRef = push(serversRef);
        const newServerId = newServerRef.key;
        
        await set(newServerRef, {
            name: serverName,
            createdBy: currentUser.uid,
            createdAt: Date.now(),
            members: {
                [currentUser.uid]: {
                    username: currentUser.username,
                    role: "owner"
                }
            }
        });
        
        // Create a default "general" channel as public with access for all members
        const channelsRef = ref(db, `servers/${newServerId}/channels`);
        const generalChannelRef = push(channelsRef);
        await set(generalChannelRef, {
            name: "general",
            createdBy: currentUser.uid,
            createdAt: Date.now(),
            type: "public", // Set the channel as public
            allowedMembers: {
                [currentUser.uid]: true  // Owner always has access
            }
        });
        
        alert(`âœ… Server "${serverName}" created successfully!`);
        createServerPopUp.style.display = "none";
        document.getElementById("serverNameInput").value = "";
        loadServers();
    } catch (error) {
        console.error("âŒ Error creating server:", error);
        alert("Failed to create server.");
    }
});

// Delete channel
deleteChannelBtn.addEventListener("click", async () => {
 if (!selectedServer || !selectedChannel) {
 alert("âŒ Please select a server and channel first.");
 return;
 }
 
 // Check user role
 const userRole = await getCurrentUserRole(selectedServer.id, currentUser.uid);
 if (userRole !== "admin" && userRole !== "owner") {
 alert("âŒ Only admins and owners can delete channels.");
 return;
 }
 
 const confirmDelete = confirm(`Are you sure you want to delete the channel "${selectedChannel.name}"?`);
 if (confirmDelete) {
 try {
 const channelRef = ref(db, `servers/${selectedServer.id}/channels/${selectedChannel.id}`);
 await remove(channelRef);
 
 alert(`âœ… Channel "${selectedChannel.name}" deleted successfully!`);
 
 // Reset view
 document.getElementById("messages").innerHTML = "";
 document.getElementById("chatChannelName").textContent = "Select a channel to chat";
 document.getElementById("messageInput").disabled = true;
 selectedChannel = null;
 window.selectedChannel = null;
 
 // Reload channels
 loadChannels(selectedServer.id);
 } catch (error) {
 console.error("âŒ Error deleting channel:", error);
 alert("Failed to delete channel.");
 }
 }
 });
 
 // Add member
 addMemberBtn.addEventListener("click", async () => {
 if (!selectedServer) {
 alert("âŒ Please select a server first.");
 return;
 }
 
 addMemberPopUp.style.display = "flex";
 });
 
 closeAddMemberBtn.addEventListener("click", () => {
 addMemberPopUp.style.display = "none";
 });
 
 // Add member to server and grant access to public channels
 async function addMemberToServer(serverId, userId, username) {
  try {
    // Add member to server
    await set(ref(db, `servers/${serverId}/members/${userId}`), {
      username: username,
      role: "member"
    });
    
    // Get all channels in the server
    const channelsRef = ref(db, `servers/${serverId}/channels`);
    const channelsSnapshot = await get(channelsRef);
    
    if (channelsSnapshot.exists()) {
      channelsSnapshot.forEach(async (channelSnap) => {
        const channelId = channelSnap.key;
        const channel = channelSnap.val();
        
        // Grant access to all public channels and general channel
        if (channel.type === "public" || channel.name === "general") {
          await set(ref(db, `servers/${serverId}/channels/${channelId}/allowedMembers/${userId}`), true);
        }
      });
    }
    
    return true;
  } catch (error) {
    console.error("Error adding member to server:", error);
    return false;
  }
 }
 
 // Update the Add Member functionality to grant access to public channels
 confirmAddMemberBtn.addEventListener("click", async () => {
    const username = document.getElementById("memberUsernameInput").value.trim();
    if (!username) {
        alert("Please enter a username.");
        return;
    }
    
    if (!selectedServer) {
        alert("âŒ No server selected.");
        return;
    }
    
    try {
        const usersSnapshot = await get(ref(db, "users"));
        let userFound = false;
        let addedUserId = null;
        
        usersSnapshot.forEach((userSnap) => {
            const user = userSnap.val();
            if (user.username === username) {
                userFound = true;
                addedUserId = userSnap.key;
            }
        });
        
        if (userFound && addedUserId) {
            // Add member to server and grant access to public channels
            const success = await addMemberToServer(selectedServer.id, addedUserId, username);
            
            if (success) {
                alert(`âœ… ${username} was added to ${selectedServer.name} successfully!`);
                addMemberPopUp.style.display = "none";
                document.getElementById("memberUsernameInput").value = "";
            } else {
                alert("âŒ Failed to add member. Please try again.");
            }
        } else {
            alert("âŒ User not found.");
        }
    } catch (error) {
        console.error("âŒ Error adding member:", error);
        alert("Failed to add member.");
    }
 });

 document.getElementById("manageChannelAccess").addEventListener("click", async () => {
    if (!selectedServer || !selectedChannel) {
        alert("Please select a server and channel first.");
        return;
    }

    try {
        const membersRef = ref(db, `servers/${selectedServer.id}/members`);
        const membersSnapshot = await get(membersRef);
        
        if (!membersSnapshot.exists()) {
            alert("No members found in this server.");
            return;
        }

        const allowedMembersRef = ref(db, `servers/${selectedServer.id}/channels/${selectedChannel.id}/allowedMembers`);
        const allowedSnapshot = await get(allowedMembersRef);

        const modal = document.createElement("div");
        modal.className = "popUp";
        modal.id = "channelAccessModal";
        modal.style.display = "flex";

        const modalContent = document.createElement("div");
        modalContent.className = "popUp-content";
        modalContent.style.width = "400px";

        const closeButton = document.createElement("span");
        closeButton.className = "close-button";
        closeButton.innerHTML = "&times;";
        closeButton.onclick = () => document.body.removeChild(modal);

        const title = document.createElement("h2");
        title.textContent = "Manage Channel Access";

        // Channel type toggle
        const channelTypeDiv = document.createElement("div");
        channelTypeDiv.style.margin = "15px 0";
        channelTypeDiv.style.padding = "10px";
        channelTypeDiv.style.backgroundColor = "#f5f5f5";
        channelTypeDiv.style.borderRadius = "5px";
        
        const channelTypeLabel = document.createElement("div");
        channelTypeLabel.style.marginBottom = "10px";
        channelTypeLabel.style.fontWeight = "bold";
        channelTypeLabel.textContent = "Channel Type:";
        
        const channelTypeToggle = document.createElement("div");
        channelTypeToggle.style.display = "flex";
        channelTypeToggle.style.gap = "15px";
        
        // Get current channel type
        const channelRef = ref(db, `servers/${selectedServer.id}/channels/${selectedChannel.id}`);
        const channelSnapshot = await get(channelRef);
        const channelType = channelSnapshot.val().type || "private"; // Default to private if not set
        
        const publicOption = document.createElement("label");
        publicOption.style.display = "flex";
        publicOption.style.alignItems = "center";
        publicOption.style.cursor = "pointer";
        
        const publicRadio = document.createElement("input");
        publicRadio.type = "radio";
        publicRadio.name = "channelTypeToggle";
        publicRadio.value = "public";
        publicRadio.checked = channelType === "public";
        publicRadio.style.marginRight = "8px";
        
        const publicText = document.createTextNode("Public");
        publicOption.appendChild(publicRadio);
        publicOption.appendChild(publicText);
        
        const privateOption = document.createElement("label");
        privateOption.style.display = "flex";
        privateOption.style.alignItems = "center";
        privateOption.style.cursor = "pointer";
        
        const privateRadio = document.createElement("input");
        privateRadio.type = "radio";
        privateRadio.name = "channelTypeToggle";
        privateRadio.value = "private";
        privateRadio.checked = channelType === "private";
        privateRadio.style.marginRight = "8px";
        
        const privateText = document.createTextNode("Private");
        privateOption.appendChild(privateRadio);
        privateOption.appendChild(privateText);
        
        channelTypeToggle.appendChild(publicOption);
        channelTypeToggle.appendChild(privateOption);
        const channelTypeDescription = document.createElement("p");
        channelTypeDescription.style.fontSize = "12px";
        channelTypeDescription.style.color = "#666";
        channelTypeDescription.style.marginTop = "8px";
        channelTypeDescription.innerHTML = "Public: All members can access<br>Private: Only allowed members can access";
        
        const saveTypeButton = document.createElement("button");
        saveTypeButton.style.marginTop = "10px";
        saveTypeButton.style.backgroundColor = "#2196F3";
        saveTypeButton.style.color = "white";
        saveTypeButton.style.border = "none";
        saveTypeButton.style.padding = "5px 10px";
        saveTypeButton.style.borderRadius = "3px";
        saveTypeButton.style.cursor = "pointer";
        saveTypeButton.textContent = "Update Channel Type";
        
        saveTypeButton.addEventListener("click", async () => {
            const newType = document.querySelector('input[name="channelTypeToggle"]:checked').value;
            
            try {
                // Update channel type
                await update(ref(db, `servers/${selectedServer.id}/channels/${selectedChannel.id}`), {
                    type: newType
                });
                
                // If changing to public, add all members
                if (newType === "public") {
                    const allMembers = {};
                    membersSnapshot.forEach(memberSnap => {
                        allMembers[memberSnap.key] = true;
                    });
                    
                    await update(ref(db, `servers/${selectedServer.id}/channels/${selectedChannel.id}/allowedMembers`), allMembers);
                }
                
                alert(`âœ… Channel type updated to ${newType}`);
                modal.remove();
                document.getElementById("manageChannelAccess").click();
            } catch (error) {
                console.error("Error updating channel type:", error);
                alert("Failed to update channel type");
            }
        });
        
        channelTypeDiv.appendChild(channelTypeLabel);
        channelTypeDiv.appendChild(channelTypeToggle);
        channelTypeDiv.appendChild(channelTypeDescription);
        channelTypeDiv.appendChild(saveTypeButton);
        
        // Member access management
        const membersList = document.createElement("div");
        membersList.style.textAlign = "left";
        membersList.style.marginTop = "20px";
        
        const membersTitle = document.createElement("h3");
        membersTitle.textContent = "Member Access";
        membersTitle.style.marginBottom = "10px";
        
        membersSnapshot.forEach((memberSnap) => {
            const memberId = memberSnap.key;
            const memberData = memberSnap.val();
            const username = typeof memberData === 'object' ? memberData.username : memberData;
            const role = typeof memberData === 'object' ? memberData.role || "member" : "member";

            // Skip admins and owners as they always have access
            if (role === "admin" || memberId === selectedServer.createdBy) {
                return;
            }

            const memberItem = document.createElement("div");
            memberItem.className = "channel-access-item";

            const memberInfo = document.createElement("div");
            memberInfo.innerHTML = `<strong>${username}</strong>`;

            const actionBtn = document.createElement("button");
            actionBtn.className = "channel-access-button";

            const isAllowed = allowedSnapshot.exists() && allowedSnapshot.hasChild(memberId);
            if (isAllowed) {
                actionBtn.textContent = "Remove Access";
                actionBtn.classList.add("remove-access");
                actionBtn.onclick = async () => {
                    await remove(ref(db, `servers/${selectedServer.id}/channels/${selectedChannel.id}/allowedMembers/${memberId}`));
                    modal.remove();
                    document.getElementById("manageChannelAccess").click();
                };
            } else {
                actionBtn.textContent = "Allow Access";
                actionBtn.classList.add("allow-access");
                actionBtn.onclick = async () => {
                    await set(ref(db, `servers/${selectedServer.id}/channels/${selectedChannel.id}/allowedMembers/${memberId}`), true);
                    modal.remove();
                    document.getElementById("manageChannelAccess").click();
                };
            }

            memberItem.appendChild(memberInfo);
            memberItem.appendChild(actionBtn);
            membersList.appendChild(memberItem);
        });

        // Check for pending access requests
        const pendingRequestsDiv = document.createElement("div");
        pendingRequestsDiv.style.marginTop = "20px";
        
        const pendingRequestsTitle = document.createElement("h3");
        pendingRequestsTitle.textContent = "Pending Access Requests";
        pendingRequestsTitle.style.marginBottom = "10px";
        
        const requestsRef = ref(db, `accessRequests/${selectedServer.id}/${selectedChannel.id}`);
        const requestsSnapshot = await get(requestsRef);
        
        if (requestsSnapshot.exists()) {
            let hasPendingRequests = false;
            
            requestsSnapshot.forEach(requestSnap => {
                const userId = requestSnap.key;
                const request = requestSnap.val();
                
                if (request.status === "pending") {
                    hasPendingRequests = true;
                    
                    const requestItem = document.createElement("div");
                    requestItem.className = "channel-access-item";
                    
                    const requestInfo = document.createElement("div");
                    requestInfo.innerHTML = `<strong>${request.username}</strong> - ${new Date(request.requestedAt).toLocaleString()}`;
                    
                    const buttonsDiv = document.createElement("div");
                    buttonsDiv.style.display = "flex";
                    buttonsDiv.style.gap = "5px";
                    
                    const approveBtn = document.createElement("button");
                    approveBtn.className = "channel-access-button allow-access";
                    approveBtn.textContent = "Approve";
                    approveBtn.onclick = async () => {
                        // Grant access
                        await set(ref(db, `servers/${selectedServer.id}/channels/${selectedChannel.id}/allowedMembers/${userId}`), true);
                        
                        // Update request status
                        await update(ref(db, `accessRequests/${selectedServer.id}/${selectedChannel.id}/${userId}`), {
                            status: "approved",
                            resolvedAt: Date.now()
                        });
                        
                        modal.remove();
                        document.getElementById("manageChannelAccess").click();
                    };
                    
                    const denyBtn = document.createElement("button");
                    denyBtn.className = "channel-access-button remove-access";
                    denyBtn.textContent = "Deny";
                    denyBtn.onclick = async () => {
                        // Update request status
                        await update(ref(db, `accessRequests/${selectedServer.id}/${selectedChannel.id}/${userId}`), {
                            status: "denied",
                            resolvedAt: Date.now()
                        });
                        
                        modal.remove();
                        document.getElementById("manageChannelAccess").click();
                    };
                    
                    buttonsDiv.appendChild(approveBtn);
                    buttonsDiv.appendChild(denyBtn);
                    
                    requestItem.appendChild(requestInfo);
                    requestItem.appendChild(buttonsDiv);
                    pendingRequestsDiv.appendChild(requestItem);
                }
            });
            
            if (!hasPendingRequests) {
                const noRequestsMsg = document.createElement("p");
                noRequestsMsg.style.color = "#666";
                noRequestsMsg.style.fontStyle = "italic";
                noRequestsMsg.textContent = "No pending access requests";
                pendingRequestsDiv.appendChild(noRequestsMsg);
            }
        } else {
            const noRequestsMsg = document.createElement("p");
            noRequestsMsg.style.color = "#666";
            noRequestsMsg.style.fontStyle = "italic";
            noRequestsMsg.textContent = "No pending access requests";
            pendingRequestsDiv.appendChild(noRequestsMsg);
        }
        
        modalContent.appendChild(closeButton);
        modalContent.appendChild(title);
        modalContent.appendChild(channelTypeDiv);
        modalContent.appendChild(membersTitle);
        modalContent.appendChild(membersList);
        modalContent.appendChild(pendingRequestsDiv);
        modal.appendChild(modalContent);
        document.body.appendChild(modal);

    } catch (error) {
        console.error("Error managing channel access:", error);
        alert("Failed to load channel access management.");
    }
});
// Manage Members
document.getElementById("manageMembers").addEventListener("click", async function() {
    if (!window.selectedServer) {
        alert("âŒ Please select a server first.");
        document.getElementById("settingsDropdown").style.display = "none";
        return;
    }
    
    try {
        const serverId = window.selectedServer.id;
        
        // Get current user role (to check permissions)
        const currentUserId = auth.currentUser.uid;
        const userRole = await getCurrentUserRole(serverId, currentUserId);
        
        // Get members
        const membersRef = ref(db, `servers/${serverId}/members`);
        const membersSnapshot = await get(membersRef);
        
        if (!membersSnapshot.exists()) {
            alert("âŒ No members found in this server.");
            document.getElementById("settingsDropdown").style.display = "none";
            return;
        }
        
        // Create modal
        const modal = document.createElement("div");
        modal.className = "popUp";
        modal.id = "memberManagementModal";
        modal.style.display = "flex";
        
        // Create modal content
        const modalContent = document.createElement("div");
        modalContent.className = "popUp-content";
        modalContent.style.width = "400px";
        modalContent.style.maxHeight = "80vh";
        modalContent.style.overflowY = "auto";
        
        // Add close button
        const closeButton = document.createElement("span");
        closeButton.className = "close-button";
        closeButton.innerHTML = "&times;";
        closeButton.onclick = () => document.body.removeChild(modal);
        
        // Add title
        const title = document.createElement("h2");
        title.textContent = "Manage Server Members";
        title.style.marginBottom = "20px";
        
        // Add members list
        const membersList = document.createElement("div");
        membersList.style.textAlign = "left";
        
        // Get server data to identify owner
        const serverRef = ref(db, `servers/${serverId}`);
        const serverSnapshot = await get(serverRef);
        const server = serverSnapshot.val();
        
        // Populate members list
        membersSnapshot.forEach((memberSnap) => {
            const memberId = memberSnap.key;
            const memberData = memberSnap.val();
            
            // Extract username and role
            let username = memberData;
            let role = "member";
            
            if (typeof memberData === "object") {
                username = memberData.username || "Unknown";
                role = memberData.role || "member";
            }
            
            // For owner role, check if this member is the creator
            if (memberId === server.createdBy) {
                role = "owner";
            }
            
            // Create member item
            const memberItem = document.createElement("div");
            memberItem.style.padding = "10px";
            memberItem.style.margin = "10px 0";
            memberItem.style.backgroundColor = "#f1f1f1";
            memberItem.style.borderRadius = "5px";
            memberItem.style.display = "flex";
            memberItem.style.justifyContent = "space-between";
            memberItem.style.alignItems = "center";
            
            // Member info
            const memberInfo = document.createElement("div");
            memberInfo.innerHTML = `
                <strong>${username}</strong>
                <span style="margin-left: 10px; padding: 2px 6px; background: ${
                role === "owner" ? "#ff9800" : 
                role === "admin" ? "#4CAF50" : "#2196F3"
                }; color: white; border-radius: 3px; font-size: 12px;">
                ${role}
                </span>
            `;
            
            // Action buttons
            const actionButtons = document.createElement("div");
            actionButtons.style.display = "flex";
            actionButtons.style.gap = "5px";
            
            // Only show actions if current user has proper permissions
            // Owner can do everything
            if (userRole === "owner" && memberId !== currentUserId) {
                // Transfer ownership button (for any member)
                const transferOwnershipBtn = document.createElement("button");
                transferOwnershipBtn.textContent = "Make Owner";
                transferOwnershipBtn.style.backgroundColor = "#FF9800";
                transferOwnershipBtn.style.color = "white";
                transferOwnershipBtn.style.border = "none";
                transferOwnershipBtn.style.padding = "5px 10px";
                transferOwnershipBtn.style.borderRadius = "3px";
                transferOwnershipBtn.style.cursor = "pointer";
                transferOwnershipBtn.style.fontSize = "12px";
                
                transferOwnershipBtn.onclick = async () => {
                    try {
                        if (confirm(`Are you sure you want to transfer ownership of "${server.name}" to ${username}? You will become an admin.`)) {
                            // Update the selected member to owner
                            await set(ref(db, `servers/${serverId}/members/${memberId}`), {
                                username: username,
                                role: "owner"
                            });
                            
                            // Update current owner to admin
                            await set(ref(db, `servers/${serverId}/members/${currentUserId}`), {
                                username: currentUser.username,
                                role: "admin"
                            });
                            
                            // Update server creator field
                            await set(ref(db, `servers/${serverId}/createdBy`), memberId);
                            
                            alert(`âœ… Ownership of "${server.name}" has been transferred to ${username}.`);
                            document.body.removeChild(modal);
                            
                            // Reset the view and go back to server list
                            serverSectionView.style.display = "block";
                            channelSectionView.style.display = "none";
                            membersSidebar.style.display = "none";
                            document.getElementById("messages").innerHTML = "";
                            document.getElementById("chatChannelName").textContent = "Select a server and channel to chat";
                            document.getElementById("messageInput").disabled = true;
                            selectedServer = null;
                            selectedChannel = null;
                            window.selectedServer = null;
                            window.selectedChannel = null;
                            
                            // Reload servers
                            loadServers();
                        }
                    } catch (error) {
                        console.error("Error transferring ownership:", error);
                        alert("Failed to transfer ownership. See console for details.");
                    }
                };
                
                actionButtons.appendChild(transferOwnershipBtn);
                
                // Promote button (for members)
                if (role === "member") {
                    const promoteBtn = document.createElement("button");
                    promoteBtn.textContent = "Promote";
                    promoteBtn.style.backgroundColor = "#4CAF50";
                    promoteBtn.style.color = "white";
                    promoteBtn.style.border = "none";
                    promoteBtn.style.padding = "5px 10px";
                    promoteBtn.style.borderRadius = "3px";
                    promoteBtn.style.cursor = "pointer";
                    promoteBtn.style.fontSize = "12px";
                    
                    promoteBtn.onclick = async () => {
                        try {
                            // Store both username and role
                            await set(ref(db, `servers/${serverId}/members/${memberId}`), {
                                username: username,
                                role: "admin"
                            });
                            
                            alert(`âœ… ${username} has been promoted to admin!`);
                            document.body.removeChild(modal);
                            // Re-open the modal to refresh
                            document.getElementById("manageMembers").click();
                        } catch (error) {
                            console.error("Error promoting member:", error);
                            alert("Failed to promote member. See console for details.");
                        }
                    };
                    
                    actionButtons.appendChild(promoteBtn);
                }
                
                // Demote button (for admins)
                if (role === "admin") {
                    const demoteBtn = document.createElement("button");
                    demoteBtn.textContent = "Demote";
                    demoteBtn.style.backgroundColor = "#f44336";
                    demoteBtn.style.color = "white";
                    demoteBtn.style.border = "none";
                    demoteBtn.style.padding = "5px 10px";
                    demoteBtn.style.borderRadius = "3px";
                    demoteBtn.style.cursor = "pointer";
                    demoteBtn.style.fontSize = "12px";
                    
                    demoteBtn.onclick = async () => {
                        try {
                            // Store both username and role
                            await set(ref(db, `servers/${serverId}/members/${memberId}`), {
                                username: username,
                                role: "member"
                            });
                            
                            alert(`âœ… ${username} has been demoted to member!`);
                            document.body.removeChild(modal);
                            // Re-open the modal to refresh
                            document.getElementById("manageMembers").click();
                        } catch (error) {
                            console.error("Error demoting member:", error);
                            alert("Failed to demote member. See console for details.");
                        }
                    };
                    
                    actionButtons.appendChild(demoteBtn);
                }
                
                // Remove button (for all except owner)
                if (role !== "owner") {
                    const removeBtn = document.createElement("button");
                    removeBtn.textContent = "Remove";
                    removeBtn.style.backgroundColor = "#9e9e9e";
                    removeBtn.style.color = "white";
                    removeBtn.style.border = "none";
                    removeBtn.style.padding = "5px 10px";
                    removeBtn.style.borderRadius = "3px";
                    removeBtn.style.cursor = "pointer";
                    removeBtn.style.fontSize = "12px";
                    
                    removeBtn.onclick = async () => {
                        try {
                            if (confirm(`Are you sure you want to remove ${username} from the server?`)) {
                                await remove(ref(db, `servers/${serverId}/members/${memberId}`));
                                alert(`âœ… ${username} has been removed from the server!`);
                                document.body.removeChild(modal);
                                // Re-open the modal to refresh
                                document.getElementById("manageMembers").click();
                            }
                        } catch (error) {
                            console.error("Error removing member:", error);
                            alert("Failed to remove member. See console for details.");
                        }
                    };
                    
                    actionButtons.appendChild(removeBtn);
                }
            } 
            // Admin can remove regular members, but not other admins or owner
            else if (userRole === "admin" && role === "member" && memberId !== currentUserId) {
                const removeBtn = document.createElement("button");
                removeBtn.textContent = "Remove";
                removeBtn.style.backgroundColor = "#9e9e9e";
                removeBtn.style.color = "white";
                removeBtn.style.border = "none";
                removeBtn.style.padding = "5px 10px";
                removeBtn.style.borderRadius = "3px";
                removeBtn.style.cursor = "pointer";
                removeBtn.style.fontSize = "12px";
                
                removeBtn.onclick = async () => {
                    try {
                        if (confirm(`Are you sure you want to remove ${username} from the server?`)) {
                            await remove(ref(db, `servers/${serverId}/members/${memberId}`));
                            alert(`âœ… ${username} has been removed from the server!`);
                            document.body.removeChild(modal);
                            // Re-open the modal to refresh
                            document.getElementById("manageMembers").click();
                        }
                    } catch (error) {
                        console.error("Error removing member:", error);
                        alert("Failed to remove member. See console for details.");
                    }
                };
                
                actionButtons.appendChild(removeBtn);
            }
            
            memberItem.appendChild(memberInfo);
            memberItem.appendChild(actionButtons);
            membersList.appendChild(memberItem);
        });
        
        // Assemble modal
        modalContent.appendChild(closeButton);
        modalContent.appendChild(title);
        modalContent.appendChild(membersList);
        modal.appendChild(modalContent);
        
        // Add to page
        document.body.appendChild(modal);
        
    } catch (error) {
        console.error("Error showing member management:", error);
        alert("âŒ Failed to load member management. See console for details.");
    }
    
    document.getElementById("settingsDropdown").style.display = "none";
});
// Leave server functionality
leaveServerBtn.addEventListener("click", async function() {
    if (!window.selectedServer) {
        alert("âŒ Please select a server first.");
        return;
    }
    
    const serverId = window.selectedServer.id;
    const userId = auth.currentUser.uid;
    
    try {
        // Get user role
        const userRole = await getCurrentUserRole(serverId, userId);
        
        // Check if user is owner - owners should not be able to directly leave
        if (userRole === "owner") {
            alert("âŒ As the server owner, you must transfer ownership before leaving the server.");
            return;
        }
        
        // Confirm leaving
        const confirmLeave = confirm(`Are you sure you want to leave the server "${window.selectedServer.name}"?`);
        if (!confirmLeave) {
            return;
        }
        
        // Remove the user from the server members
        await remove(ref(db, `servers/${serverId}/members/${userId}`));
        
        alert(`âœ… You have left the server "${window.selectedServer.name}".`);
        
        // Reset view and go back to server list
        serverSectionView.style.display = "block";
        channelSectionView.style.display = "none";
        membersSidebar.style.display = "none";
        document.getElementById("messages").innerHTML = "";
        document.getElementById("chatChannelName").textContent = "Select a server and channel to chat";
        document.getElementById("messageInput").disabled = true;
        selectedServer = null;
        selectedChannel = null;
        window.selectedServer = null;
        window.selectedChannel = null;
        
        // Reload servers
        loadServers();
    } catch (error) {
        console.error("âŒ Error leaving server:", error);
        alert("Failed to leave server. See console for details.");
    }
    
    document.getElementById("settingsDropdown").style.display = "none";
});

 // Delete server
 const deleteServerBtn = document.getElementById("deleteServer");
 if (deleteServerBtn) {
 deleteServerBtn.addEventListener("click", async () => {
 if (!selectedServer) {
 alert("âŒ Please select a server first.");
 return;
 }
 
 // Check if user is owner
 const userRole = await getCurrentUserRole(selectedServer.id, currentUser.uid);
 if (userRole !== "owner") {
 alert("âŒ Only the server owner can delete the server.");
 return;
 }
 
 const confirmDelete = confirm(`Are you sure you want to delete the server "${selectedServer.name}"? This action cannot be undone.`);
 if (confirmDelete) {
 try {
 const serverRef = ref(db, `servers/${selectedServer.id}`);
 await remove(serverRef);
 
 alert(`âœ… Server "${selectedServer.name}" deleted successfully!`);
 
 // Reset view and go back to server list
 serverSectionView.style.display = "block";
 channelSectionView.style.display = "none";
 membersSidebar.style.display = "none";
 document.getElementById("messages").innerHTML = "";
 document.getElementById("chatChannelName").textContent = "Select a server and channel to chat";
 document.getElementById("messageInput").disabled = true;
 selectedServer = null;
 selectedChannel = null;
 window.selectedServer = null;
 window.selectedChannel = null;
 
 // Reload servers
 loadServers();
 } catch (error) {
 console.error("âŒ Error deleting server:", error);
 alert("Failed to delete server.");
 }
 }
 });
 }
 });

 // Logout
 document.getElementById("logoutButton").addEventListener("click", function () {
 console.log("ğŸš€ Logout button clicked!");

 signOut(auth).then(() => {
 console.log("âœ… User logged out. Redirecting...");
 window.top.location.href = "../../Sprint1/LoginPage/user_login.html";
 }).catch((error) => {
 console.error("âŒ Logout failed:", error);
 });
 });

 // Make variables available globally
 window.selectedServer = selectedServer;
 window.selectedChannel = selectedChannel;
 window.getCurrentUserRole = getCurrentUserRole;
 window.canAccessChannel = canAccessChannel;
 window.grantGeneralChannelAccess = grantGeneralChannelAccess;
 </script>
 <script type="module" src="./memberHandler.js"></script>
</body>
</html>
